# Wildcards in Target Rules


:::{- .objectives} 
### Overview {-}

**Questions**

- How can we use wildcards to simplify target rules?
- How do we make the build plan explicit in target rules?
- How do we combine more than one wildcard in a single target rule?

**Objectives**

- Introduce wildcards to target rules
- Explain what the `expand()` function is and how to ues it
- Learn how to use multiple wildcards in a single rule

:::

In the last chapter we have learned how to use wildcards to eliminate unnecessary repetitions in our code.
In this chapter we will learn how to apply wildcards to our target rules with help of the `expand()` function.

:::{- .prereq}
### Snakefile Status {-}

After the last chapter our Snakefile should look like this:

```{r, engine = 'bash', eval = FALSE}
# --- Target Rules --- #

rule solow_target:
    input:
        intermediate = "out/analysis/model_solow_subset_intermediate.rds",
        nonoil       = "out/analysis/model_solow_subset_nonoil.rds",
        oecd         = "out/analysis/model_solow_subset_oecd.rds"


# --- Build Rules --- #

rule solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_solow.json",
        subset = "src/data-specs/subset_{iSubset}.json"
    output:
        estimate = "out/analysis/model_solow_subset_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"

rule gen_regression_vars:
    input:
        script = "src/data-management/gen_reg_vars.R",
        data   = "out/data/mrw_renamed.csv",
        param  = "src/data-specs/param_solow.json"
    output:
        data   = "out/data/mrw_complete.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --param {input.param} \
            --out {output.data}"

rule rename_vars:
    input:
        script = "src/data-management/rename_variables.R",
        data   = "src/data/mrw.dta"
    output:
        data = "out/data/mrw_renamed.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --out {output.data}"

# --- Clean Rules --- #

rule clean:
    shell:
        "rm -rf out/*"

rule clean_data:
    shell:
        "rm -rf out/data/*"

rule clean_analysis:
    shell:
        "rm -rf out/analysis/*"
```

This will be our starting point for this chapter.
:::

## The `expand()` function

When we look at our target rule:

```{r, engine = 'out', eval = FALSE}
rule solow_target:
    input:
        intermediate = "out/analysis/model_solow_subset_intermediate.rds",
        nonoil       = "out/analysis/model_solow_subset_nonoil.rds",
        oecd         = "out/analysis/model_solow_subset_oecd.rds"
```

We can see that the inputs have a very similar structure:

* The inputs live on the same path `out/analysis/`
* The filenames of each input begin with `model_solow_subset` and end with `.rds`.  

They only differ in the name of the subset of data we are using: `intermediate`, `nonoil`, and `oecd`.

After the wildcards chapter, our Spidy senses should be tingling.
Maybe we can just add a wildcard for the varying part of the input files and replace it with a single input:


```{r, engine = 'out', eval = FALSE}
rule solow_target:
    input:
        models = "out/analysis/model_solow_subset_{iSubset}.rds",

```

Let us clean our output folder 

```{r, engine = 'out', eval = FALSE}
$ snakemake --cores 1 clean
```

and run our new target rule with wildcards

```{r, engine = 'out', eval = FALSE}
$ snakemake --cores 1 solow_target
```

which gives us the following error:

```{r, engine = 'out', eval = FALSE}
Building DAG of jobs...
WildcardError in line 12 of /home/lachlan/teaching/snakemake-econ-r-learner/Snakefile:
Wildcards in input files cannot be determined from output files:
'iSubset'
```

Well, that didn't work.

We remember from the Wildcard Chapter that Snakemake won't run a target rule that contains a wildcard because it does not know how to resolve it.
Snakemake doesn't know that `{iSubset}`  should first be replaced with `oecd`, then with `intermediate`, and finally with `nonoil`.
It is our job to be a bit more explicit and tell Snakemake that this is what we want to happen.

Luckily Snakemake has a functionality that allows us to tell it how to accept a wildcard and replace it with a set of specific values.
The `expand()` function provides this for us.
As the name suggests its job is to expand a wildcard by replacing it iteratively with specified values.

We can use the `expand()` function as follows:

```{r, engine = 'out', eval = FALSE}
rule solow_target:
    input:
        expand("out/analysis/model_solow_subset_{iSubset}.rds",
                    iSubset = DATA_SUBSET)
```

This tells Snakemake to replace the wildcard `{iSubset}` with values from `DATA_SUBSET`.
We now only have to replace `DATA_SUBSET` with a list of values that we want to substitute for`{iSubset}`.

## Using `expand()` With a List

In Python and Snakemake lists are denoted by `[]` with the elements of the list within the brackets. 
In our case, a list of the three subsets of the data looks like this: `["nonoil", "oecd", "intermediate"]`.

Let us replace `DATA_SUBSET` with our new list of subset names:

```{r, engine = 'out', eval = FALSE}
rule solow_target:
    input:
        expand("out/analysis/model_solow_subset_{iSubset}.rds",
                    iSubset = ["nonoil", "oecd", "intermediate"])
```

We use the `--summary` option of Snakemake to see the build plan:

```{r, engine = 'out', eval = FALSE}
$ snakemake --summary
```

```{r, engine = 'out', eval = FALSE}
output_file     date    rule    version log-file(s)     status  plan
out/analysis/model_solow_subset_nonoil.rds         -       solow_model     -               missing update pending
out/analysis/model_solow_subset_oecd.rds           -       solow_model     -               missing update pending
out/analysis/model_solow_subset_intermediate.rds   -       solow_model     -               missing update pending
out/data/mrw_complete.csv       -       gen_regression_vars     -               missing update pending
out/data/mrw_renamed.csv        -       rename_vars     -               missing update pending
```


The first three lines show us that Snakemake plans to build the three files `out/analysis/model_solow_subset_nonoil.rds`, `out/analysis/model_solow_subset_oecd.rds`, `out/analysis/model_solow_subset_intermediate.rds` from our original target rule.
This means Snakemake has indeed replaced the wildcard `iSubset` with the correct three values just like we wanted
^[
    And we were not thrown an error message.
]
and we have successfully simplified our target rule.

:::{- .tip}

### Python3 Code Outside of Rules {-}

Snakemake accepts any Python3 code outside of rules.
You can add Python3 lists or functions anywhere in a Snakefile.

:::

So far, we defined the list we pass to the expand function in the Snakemake rule itself.
For the following three reasons it might be a better idea to define it outside of it:

1. If we want to re-use the same list of values in another rule, we would have to write the list again or copy and paste it into the second rule.
As before, this introduces extra room for errors.
If we copy and paste a list several times, we probably could've lived without wildcards and the `expand()` function in the first place.
2. It can be hard to find the lists we are iterating over when we read through the Snakefile. Putting all lists we are using at the top of `Snakefile` makes this easier.
3. In the next chapter we will introduce a new function which allows us to construct lists which we pass to `expand()` from the files in our project automatically.
For this task it will be very advantageous to define lists outside of rules.

Let us therefore now create our list of data subsets at the beginning of our Snakefile and reference it in the rule.
To do so, let us create a list called `DATA_SUBSET`^[
    We capitalize lists that we iterate over to separate them from other parts of code. This is not essential but makes life a bit easier sometimes. Whenever you see a capitalized name, you know it is a list that we want to iterate over.] at the top of `Snakefile` which has our three subsets of data: 

```{r, engine = 'out', eval = FALSE}
DATA_SUBSET = ["oecd", "intermediate", "nonoil"]
```

We then need to refer to the list by name inside our `expand()` function.
To do so, we replace the explicit list we had before with the name of our newly constructed `DATA_SUBSET` list:

```{r, engine = 'out', eval = FALSE}
rule solow_target:
    input:
        expand("out/analysis/model_solow_{iSubset}.rds",
                    iSubset = DATA_SUBSET)
```


Let us finally execute our rule:

```{r, engine = 'out', eval = FALSE}
$ snakemake --cores 1 
```

```{r, engine = 'out', eval = FALSE}
TODO: Add Output
```

Nice, everything seems to have worked. 
If we look into our output folder, we should now see the three output models:

```{r, engine = 'out', eval = FALSE}
ls out/analysis
```

```{r, engine = 'out', eval = FALSE}
TODO: ADD OUTPUT
```

::: {- .challenge} 

### Exercise: Exploring the expand function

@mrw contains three plots.
Each of these plots use the data subset of 'intermediate' countries.
The `src/figures/` subdirectory contains three scripts which correspond to the three plots in the paper.^[
This is not entirely true, we are yet to figure out how to get the y-axis range from the original paper.
]

It is your task to use what you have learned so far to create a workflow to produce the figures.
To do so, follow the following steps:

1. Write three rules `fig1`, `fig2` and `fig3` to produce each figure. 
   Each figure should be saved to the following output filepath `out/figures/SCRIPTNAME.pdf` 
2. Create a list called `PLOTS` that contains the file names of each of the three plot scripts (without the path or the `.json` file ending).
3. Use what you have learned about **wildcards** to simplify the three rules `fig1`, `fig2`, and `fig3` into a single rule called `figures`. What part of the rule needs a wildcard?
4. Use the `expand()` function to create a target rule named `make_figures`.
5. Use the summary function to check that all three figures are planned to be created correctly.
6. Create all three figures with a single execution of`snakemake --cores 1 figs_target`.
7. Make sure that the files have been written to the output folder.

HINT:
The scripts are written in such a way that they accept exactly the same options.
Check first, what inputs the scripts expect.

:::

::: {- .answer} 

### SOLUTION:

In this problem the three rules `fig1`, `fig2`, and `fig3` only differ in the `{input.model}` they take and the output filename. We therefore have use wildcards in both to unify them.
The target rule `make_figures` then uses the `expand()` function and a list of the filenames without the `.json` ending to create all three plots.

After completing all steps. your `Snakefile` should look something like this:

```{r, engine = 'bash', eval = FALSE}
# --- Dictionaries --- #

DATA_SUBSET = ["oecd",
               "intermediate",
               "nonoil"
]

PLOTS = [
    "aug_conditional_convergence",
    "conditional_convergence",
    "unconditional_convergence"
]


# --- Target Rules --- #

rule make_figures:
    input:
        expand("out/figures/{iFigure}.pdf",
                    iFigure = PLOTS)

rule solow_target:
    input:
        expand("out/analysis/model_solow_subset_{iSubset}.rds",
                    iSubset = DATA_SUBSET)


# --- Build Rules --- #

rule figures:
    input:
        script = "src/figures/{iFigure}.R",
        data   = "out/data/mrw_complete.csv",
        subset = "src/data-specs/subset_intermediate.json"
    output:
        fig = "out/figures/{iFigure}.pdf"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --subset {input.subset} \
            --out {output.fig}"

rule solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_solow.json",
        subset = "src/data-specs/{iSubset}.json"
    output:
        estimate = "out/analysis/model_solow_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"

rule gen_regression_vars:
    input:
        script = "src/data-management/gen_reg_vars.R",
        data   = "out/data/mrw_renamed.csv",
        param  = "src/data-specs/param_solow.json"
    output:
        data   = "out/data/mrw_complete.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --param {input.param} \
            --out {output.data}"

rule rename_vars:
    input:
        script = "src/data-management/rename_variables.R",
        data   = "src/data/mrw.dta"
    output:
        data = "out/data/mrw_renamed.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --out {output.data}"


# --- Clean Rules --- #

rule clean:
    shell:
        "rm -rf out/*"

rule clean_data:
    shell:
        "rm -rf out/data/*"

rule clean_analysis:
    shell:
        "rm -rf out/analysis/*"

```

You can check the summary via

```{r, engine = 'bash', eval = FALSE}
snakemake --summary make_figures 
```

run the rule via

```{r, engine = 'bash', eval = FALSE}
snakemake --cores 1 make_figures
```

and check the output via

```{r, engine = 'bash', eval = FALSE}
ls out/figures
```

:::

## The Augmented Solow Model

So far we have estimated the basic Solow model.
@mrw also estimate an augmented version of the Solow model which adds human capital.
You can find the regression model required to estimate the augmented model in `src/model-specs/model_aug_solow.json`.

In the next section we will learn how to use multiple wildcards in a single rule.
To prepare this, we will create two new rules:

-  `aug_solow_target` is identical to `solow_target` except for the rule name and the input.
- `aug_solow_model` is identical to `solow_model` except for the model spec we use.

Copy the previous two rules, modify the names of both new rules and update the `{input.model}` part of the `aug_solow_model` to the correct filepath.

After this, your `Snakefile` should look like this:

```{r, engine = 'bash', eval = FALSE}
# --- Dictionaries --- #

DATA_SUBSET = [
                "subset_oecd",
                "subset_intermediate",
                "subset_nonoil"
                ]

PLOTS = [
    "aug_conditional_convergence",
    "conditional_convergence",
    "unconditional_convergence"
]

# --- Target Rules --- #

rule solow_target:
    input:
        expand("out/analysis/model_solow_subset_{iSubset}.rds",
                    iSubset = DATA_SUBSET)

rule aug_solow_target:
    input:
        expand("out/analysis/model_aug_solow_subset_{iSubset}.rds",
                    iSubset = DATA_SUBSET)

rule make_figures:
    input:
        expand("out/figures/{iFigure}.pdf",
                    iFigure = PLOTS)

# --- Build Rules --- #

rule solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_solow.json",
        subset = "src/data-specs/subset_{iSubset}.json"
    output:
        estimate = "out/analysis/model_solow_subset_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"

rule aug_solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_aug_solow.json",
        subset = "src/data-specs/subset_{iSubset}.json"
    output:
        estimate = "out/analysis/model_aug_solow_subset_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"

rule figure:
    input:
        script = "src/figures/{iFigure}.R",
        data   = "out/data/mrw_complete.csv",
        subset = "src/data-specs/subset_intermediate.json"
    output:
        fig = "out/figures/{iFigure}.pdf"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --subset {input.subset} \
            --out {output.fig}"

rule gen_regression_vars:
    input:
        script = "src/data-management/gen_reg_vars.R",
        data   = "out/data/mrw_renamed.csv",
        param  = "src/data-specs/param_solow.json"
    output:
        data   = "out/data/mrw_complete.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --param {input.param} \
            --out {output.data}"

rule rename_vars:
    input:
        script = "src/data-management/rename_variables.R",
        data   = "src/data/mrw.dta"
    output:
        data = "out/data/mrw_renamed.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --out {output.data}"

# --- Clean Rules --- #

rule clean:
    shell:
        "rm -rf out/*"

rule clean_data:
    shell:
        "rm -rf out/data/*"

rule clean_analysis:
    shell:
        "rm -rf out/analysis/*"
```

We can now execute the rule via:

```{r, engine = 'out', eval = FALSE}
snakemake --cores 1 aug_solow_target
```


## Expanding Multiple Wildcards

The rules used to estimate the standard Solow model and the augmented Solow model are identical except for the model they use:

```{r, engine = 'out', eval = FALSE}
[...]

# --- Target Rules --- #

rule solow_target:
    input:
        expand("out/analysis/model_solow_subset_{iSubset}.rds",
                    iSubset = DATA_SUBSET)

rule aug_solow_target:
    input:
        expand("out/analysis/model_aug_solow_subset_{iSubset}.rds",
                    iSubset = DATA_SUBSET)

[...]

rule solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_solow.json",
        subset = "src/data-specs/subset_{iSubset}.json"
    output:
        estimate = "out/analysis/model_solow_subset_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"

rule aug_solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_aug_solow.json",
        subset = "src/data-specs/subset_{iSubset}.json"
    output:
        estimate = "out/analysis/model_aug_solow_subset_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"

[...]
```

We see that the only difference between the `aug_solow_target` and `solow_target` rules is that the filename differs by three letters: `out/analysis/model_aug_solow_{iSubset}.rds` versus
  `out/analysis/model_solow_{iSubset}.rds`.

And, when we look at `aug_solow_model` and compare it to `solow_model` we again see only small differences:
the model changes from `model_aug_solow.json` to `model_solow.json` and the outputs change in a similar way.

We want to exploit this similarity and condense these four rules into two:

- one that estimates the model, named `model` and 
- a target rule that will run each specification, named `run_models`.

We are going to do this by creating a new list, called `MODELS`. 
`MODELS` contain two elements, `solow` and `aug_solow`.
Let's add this to the top of our Snakefile:

```{r, engine = 'out', eval = FALSE}
MODELS = [
          "solow",
          "aug_solow"
          ]
```

Let us now unify our two target rules. 
For this, we will first delete the `aug_solow_target` rule.
Next, we will rename the `solow_target` rule into `run_models` and replace the unique part of the input model with a wildcard called `{iModel}`.
Finally, we need to add the `MODELS` list to the expand function.

This should give us something like this:

```{r, engine = 'out', eval = FALSE}
rule run_models:
    input:
        expand("out/analysis/model_{iModel}_subset_{iSubset}.rds",
                    iSubset = DATA_SUBSET,
                    iModel = MODELS)
```

Finally, we need to unify our `solow_model` and `solow_aug_model` build rules.
Let us again delete the the latter rule.
We then rename `solow_model` into `model` and add the `{iModel}` wildcard to `{input.model}`.

This should give us the following:

```{r, engine = 'out', eval = FALSE}
rule model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_{iModel}.json",
        subset = "src/data-specs/subset_{iSubset}.json"
    output:
        estimate = "out/analysis/model_{iModel}_subset_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"
```

As always, let us clean our output folder first

```{r, engine = 'bash', eval = FALSE}
snakemake --clean
```

and get the summary information from Snakemake:

```{r, engine = 'out', eval = FALSE}
$ snakemake --summary
```

which yields:

```{r, engine = 'out', eval = FALSE}
output_file     date    rule    version log-file(s)     status  plan
out/analysis/model_solow_subset_oecd.rds        -       -       -       -       missing update pending
out/analysis/model_aug_solow_subset_oecd.rds    -       -       -       -       missing update pending
out/analysis/model_solow_subset_intermediate.rds        -       -       -       -       missing update pending
out/analysis/model_aug_solow_subset_intermediate.rds    -       -       -       -       missing update pending
out/analysis/model_solow_subset_nonoil.rds      -       -       -       -       missing update pending
out/analysis/model_aug_solow_subset_nonoil.rds  -       -       -       -       missing update pending
out/data/mrw_complete.csv       -       gen_regression_vars     -               missing update pending
out/data/mrw_renamed.csv        -       rename_vars     -               missing update pending
```

This confirms that our new target and model rules work.
Snakemake plans to do the data managment steps and build all six model outputs afterwards.

The corresponding Snakemake rule graph which shows the rules we execute in our workflow is now:

```{r, fig.align="center", echo=FALSE}
knitr::include_graphics("img/ch-5c/rulegraph.pdf")
```

And the DAG is:

```{r, fig.align="center", echo=FALSE}
knitr::include_graphics("img/ch-5c/dag.pdf")
```

The DAG makes crystal clear what our workflow is doing:

* Snakemake wants to build the inputs listed in  `run_models`
* It can build those inputs by running the `model` rule six times when it iterates over the wildcards
* To run each model, it needs the clean data, so it needs to run the two data cleaning steps first

Let us finally execute our target rule:

```{r, engine = 'out', eval = FALSE}
$ snakemake --cores 1 run_models
```

::: {- .tip}

Notice how the figures aren't produced automatically. 
Do you remember why?
If not, revisit the previous chapter.
You can build them with `snakemake --cores 1 make_figures`

:::
