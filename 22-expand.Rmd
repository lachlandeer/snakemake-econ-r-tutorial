# Wildcards in Target Rules


:::{- .objectives} 
### Overview {-}

**Questions**

- How can we use wildcards to simplify target rules?
- How do we make the build plan explicit in target rules?
- How do we combine more than one wildcard?

**Objectives**

- Introduce wildcards to target rules
- Explain what the `expand()` function is and how to ues it
- Learn how to use multiple wildcards in a single rule

:::

In the last chapter we have learned how to use wildcards to eliminate unnecessary repetitions in our code.
In this chapter we will learn how to apply wildcards to our target rules with help of the `expand()` function.

:::{- .prereq}
### Snakefile Status {-}

After the last chapter our Snakefile should look like this:

```{r, engine = 'bash', eval = FALSE}
# --- Target Rules --- #

rule solow_target:
    input:
        intermediate = "out/analysis/model_solow_subset_intermediate.rds",
        nonoil       = "out/analysis/model_solow_subset_nonoil.rds",
        oecd         = "out/analysis/model_solow_subset_oecd.rds"


# --- Build Rules --- #

rule solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_solow.json",
        subset = "src/data-specs/subset_{iSubset}.json"
    output:
        estimate = "out/analysis/model_solow_subset_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"

rule gen_regression_vars:
    input:
        script = "src/data-management/gen_reg_vars.R",
        data   = "out/data/mrw_renamed.csv",
        param  = "src/data-specs/param_solow.json"
    output:
        data   = "out/data/mrw_complete.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --param {input.param} \
            --out {output.data}"

rule rename_vars:
    input:
        script = "src/data-management/rename_variables.R",
        data   = "src/data/mrw.dta"
    output:
        data = "out/data/mrw_renamed.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --out {output.data}"

# --- Clean Rules --- #

rule clean:
    shell:
        "rm -rf out/*"

rule clean_data:
    shell:
        "rm -rf out/data/*"

rule clean_analysis:
    shell:
        "rm -rf out/analysis/*"
```

This will be our starting point for this chapter.
:::

## The `expand()` function

When we look at our target rule:

```{r, engine = 'out', eval = FALSE}
rule solow_target:
    input:
        intermediate = "out/analysis/model_solow_subset_intermediate.rds",
        nonoil       = "out/analysis/model_solow_subset_nonoil.rds",
        oecd         = "out/analysis/model_solow_subset_oecd.rds"
```

We can see that the inputs have a very similar structure:

* The inputs live on the same path `out/analysis/`
* The filenames of each input begin with `model_solow_subset` and end with `.rds`.  

They only differ in the name of the subset of data we are using: `intermediate`, `nonoil`, and `oecd`.

After the wildcards chapter, our Spidy sense should be tingling.
Maybe we can just add a wildcard for the varying part of the input files and replace it with a single input:


```{r, engine = 'out', eval = FALSE}
rule solow_target:
    input:
        models = "out/analysis/model_solow_subset_{iSubset}.rds",

```

Let us clean our output folder 

```{r, engine = 'out', eval = FALSE}
$ snakemake --cores 1 clean
```

and run our new target rule with wildcards

```{r, engine = 'out', eval = FALSE}
$ snakemake --cores 1 solow_target
```

which gives us the following error:

```{r, engine = 'out', eval = FALSE}
Building DAG of jobs...
WildcardError in line 12 of /home/lachlan/teaching/snakemake-econ-r-learner/Snakefile:
Wildcards in input files cannot be determined from output files:
'iSubset'
```

Well, that didn't work.

We remember from the Wildcard Chapter that Snakemake won't run a target rule that contains a wildcard because it does not know how to resolve it.
Snakemake doesn't know that `{iSubset}`  should first be replaced with `oecd`, then with `intermediate`, and finally with `nonoil`.
It is our job to be a bit more explicit and tell Snakemake that this is what we want to happen.

Luckily Snakemake has a functionality that allows us to tell it how to accept a wildcard and replace it with a set of specific values.
The `expand()` function provides this for us.
As the name suggests its job is to expand a wildcard by replacing it iteratively with specified values.

We can use the `expand()` function as follows:

```{r, engine = 'out', eval = FALSE}
rule solow_target:
    input:
        expand("out/analysis/model_solow_subset_{iSubset}.rds",
                    iSubset = DATA_SUBSET)
```

This tells Snakemake to replace the wildcard `{iSubset}` with values from `DATA_SUBSET`.
We now only have to replace `DATA_SUBSET` with a list of values that we want to substitute for`{iSubset}`.

### Using `expand()` with a list of values

In Python and Snakemake lists are denoted by `[]` with the elements of the list within the brackets. 
In our case, a list of the three subsets of the data looks like this: `["nonoil", "oecd", "intermediate"]`.

Let us replace `DATA_SUBSET` with our new list of subset names:

```{r, engine = 'out', eval = FALSE}
rule solow_target:
    input:
        expand("out/analysis/model_solow_subset_{iSubset}.rds",
                    iSubset = ["nonoil", "oecd", "intermediate"])
```

We use the `--summary` option of Snakemake to see the build plan:

```{r, engine = 'out', eval = FALSE}
$ snakemake --summary
```

```{r, engine = 'out', eval = FALSE}
output_file     date    rule    version log-file(s)     status  plan
out/analysis/model_solow_subset_nonoil.rds         -       solow_model     -               missing update pending
out/analysis/model_solow_subset_oecd.rds           -       solow_model     -               missing update pending
out/analysis/model_solow_subset_intermediate.rds   -       solow_model     -               missing update pending
out/data/mrw_complete.csv       -       gen_regression_vars     -               missing update pending
out/data/mrw_renamed.csv        -       rename_vars     -               missing update pending
```


The first three lines show us that Snakemake plans to build the three files `out/analysis/model_solow_subset_nonoil.rds`, `out/analysis/model_solow_subset_oecd.rds`, `out/analysis/model_solow_subset_intermediate.rds` from our original target rule.
This means Snakemake has indeed replaced the wildcard `iSubset` with the correct three values just like we wanted
^[
    And we were not thrown an error message.
]
and we have successfully simplified our target rule.

:::{- .tip}

### Python3 Code Outside of Rules

Snakemake accept any Python3 code outside of rules.
You can add Python3 lists or functions anywhere in a Snakefile.

:::

So far, we defined the list we pass to the expand function in the Snakemake rule itself.
For the following three reasons it might be a better idea to define it outside of it:

1. If we want to re-use the same list of values in another rule, we would have to write it again or copy and paste it into the second rule.
As before, this introduces extra room for errors.
If we copy and paste the rule several times, we probably could've lived without wildcards and the `expand()` function in the first place.
2. It can be hard to find the lists we are iterating over when we read through the Snakefile.
3. In the next chapter we will introduce a new function which allows us to construct lists which we pass to `expand()` from the files in our project automatically.
For this task it will be very advantageous to define lists once at the beginning of our Snakefile.

Let us therefore now create our list of data subsets at the beginning of our Snakefile and reference it in the rule.
To do so, let us create a list called `DATA_SUBSET`^[
    We capitalize lists that we iterate over to separate them from other parts of code. This is not essential but makes life a bit easier sometimes. Whenever you see a capitalized name, you know it is a list that we want to iterate over.] at the top of `Snakefile` which has our three subsets of data: 

```{r, engine = 'out', eval = FALSE}
DATA_SUBSET = ["oecd", "intermediate", "nonoil"]
```

We then need to refer to the list by name inside our `expand()` function.
To do so, we replace the explicit list we had before with the name of our newly constructed `DATA_SUBSET` list:

```{r, engine = 'out', eval = FALSE}
rule solow_target:
    input:
        expand("out/analysis/model_solow_{iSubset}.rds",
                    iSubset = DATA_SUBSET)
```


Let us finally execute our rule:

```{r, engine = 'out', eval = FALSE}
$ snakemake --cores 1 
```

```{r, engine = 'out', eval = FALSE}
TODO: Add Output
```

Nice, everything seems to have worked. 
If we look into our output folder, we should now see the three output models:

```{r, engine = 'out', eval = FALSE}
ls out/analysis
```

```{r, engine = 'out', eval = FALSE}
TODO: ADD OUTPUT
```

::: {- .challenge} 

### Exercise: Exploring the expand function

The MRW paper contains three plots.
Each of these plots use the data subset of 'intermediate' countries.
In the `src/figures/` subdirectory, there are three scripts that reproduce the figures one script per plot.^[
This is not entirely true, we are yet to figure out how to get the y-axis range from the original paper.
]

It is your task to use what you have learned so far to create a workflow to produce the figures.
To do so, follow the following steps:

1. Write three rules `fig1`, `fig2` and `fig3` to produce each figure. 
   Each figure should be saved to the following output filepath `out/figures/SCRIPTNAME.pdf` 
2. Create a list called `PLOTS` that contains the file names of each of the three plot scripts (without the path or the `.json` file ending).
3. Use what you have learned about **wildcards** to simplify the three rules `fig1`, `fig2`, and `fig3` into a single rule called `figures`. What part of the rule needs a wildcard?
4. Use the `expand()` function to create a target rule named `make_figures`.
5. Use the summary function to check that all three figures are planned to be created correctly.
6. Create all three figures with a single execution of`snakemake --cores 1 figs_target`.
7. Make sure that the files have been written to the output folder.

HINT:
The scripts are written in such a way that they accept exactly the same options.
Check first, what inputs the scripts expect.

:::

::: {- .answer} 

### SOLUTION:

In this problem the three rules `fig1`, `fig2`, and `fig3` only differ in the `{input.model}` they take and the output filename. We therefore have use wildcards in both to unify them.
The target rule `make_figures` then uses the `expand()` function and a list of the filenames without the `.json` ending to create all three plots.

After completing all steps. your `Snakefile` should look something like this:

```{r, engine = 'bash', eval = FALSE}
# --- Dictionaries --- #

DATA_SUBSET = ["oecd",
               "intermediate",
               "nonoil"
]

PLOTS = [
    "aug_conditional_convergence",
    "conditional_convergence",
    "unconditional_convergence"
]


# --- Target Rules --- #

rule make_figures:
    input:
        expand("out/figures/{iFigure}.pdf",
                    iFigure = PLOTS)

rule solow_target:
    input:
        expand("out/analysis/model_solow_subset_{iSubset}.rds",
                    iSubset = DATA_SUBSET)


# --- Build Rules --- #

rule figures:
    input:
        script = "src/figures/{iFigure}.R",
        data   = "out/data/mrw_complete.csv",
        subset = "src/data-specs/subset_intermediate.json"
    output:
        fig = "out/figures/{iFigure}.pdf"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --subset {input.subset} \
            --out {output.fig}"

rule solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_solow.json",
        subset = "src/data-specs/{iSubset}.json"
    output:
        estimate = "out/analysis/model_solow_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"

rule gen_regression_vars:
    input:
        script = "src/data-management/gen_reg_vars.R",
        data   = "out/data/mrw_renamed.csv",
        param  = "src/data-specs/param_solow.json"
    output:
        data   = "out/data/mrw_complete.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --param {input.param} \
            --out {output.data}"

rule rename_vars:
    input:
        script = "src/data-management/rename_variables.R",
        data   = "src/data/mrw.dta"
    output:
        data = "out/data/mrw_renamed.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --out {output.data}"


# --- Clean Rules --- #

rule clean:
    shell:
        "rm -rf out/*"

rule clean_data:
    shell:
        "rm -rf out/data/*"

rule clean_analysis:
    shell:
        "rm -rf out/analysis/*"

```

You can check the summary via

```{r, engine = 'bash', eval = FALSE}
snakemake --summary make_figures 
```

run the rule via

```{r, engine = 'bash', eval = FALSE}
snakemake --cores 1 make_figures
```

and check the output via

```{r, engine = 'bash', eval = FALSE}
ls out/figures
```

:::

### Estimating the Augmented Solow Model

So far we have estimated the basic Solow model.
@mrw also estimate an augmented version of the Solow model which adds human capital.
You can find the regression model required to estimate the augmented model in `src/model-specs/model_aug_solow.json`.

In the next section we will learn how to use multiple wildcards in a single rule.
To prepare this, we will create two new rules:

-  `aug_solow_target` is identical to `solow_target` except for the rule name, and the input.
- `aug_solow_model` is identical to `solow_model` except for the model spec we use.

Copy the previous two rules, modify the names of both new rules and update the `{input.model}` part of the `aug_solow_model` to the correct filepath.

After this, your `Snakefile` should look like this:

```{r, engine = 'bash', eval = FALSE}
# --- Dictionaries --- #

DATA_SUBSET = [
                "subset_oecd",
                "subset_intermediate",
                "subset_nonoil"
                ]

PLOTS = [
    "aug_conditional_convergence",
    "conditional_convergence",
    "unconditional_convergence"
]

# --- Target Rules --- #

rule solow_target:
    input:
        expand("out/analysis/model_solow_subset_{iSubset}.rds",
                    iSubset = DATA_SUBSET)

rule aug_solow_target:
    input:
        expand("out/analysis/model_aug_solow_subset_{iSubset}.rds",
                    iSubset = DATA_SUBSET)

rule make_figures:
    input:
        expand("out/figures/{iFigure}.pdf",
                    iFigure = PLOTS)

# --- Build Rules --- #

rule solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_solow.json",
        subset = "src/data-specs/subset_{iSubset}.json"
    output:
        estimate = "out/analysis/model_solow_subset_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"

rule aug_solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_aug_solow.json",
        subset = "src/data-specs/subset_{iSubset}.json"
    output:
        estimate = "out/analysis/model_aug_solow_subset_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"

rule figure:
    input:
        script = "src/figures/{iFigure}.R",
        data   = "out/data/mrw_complete.csv",
        subset = "src/data-specs/subset_intermediate.json"
    output:
        fig = "out/figures/{iFigure}.pdf"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --subset {input.subset} \
            --out {output.fig}"

rule gen_regression_vars:
    input:
        script = "src/data-management/gen_reg_vars.R",
        data   = "out/data/mrw_renamed.csv",
        param  = "src/data-specs/param_solow.json"
    output:
        data   = "out/data/mrw_complete.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --param {input.param} \
            --out {output.data}"

rule rename_vars:
    input:
        script = "src/data-management/rename_variables.R",
        data   = "src/data/mrw.dta"
    output:
        data = "out/data/mrw_renamed.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --out {output.data}"

# --- Clean Rules --- #

rule clean:
    shell:
        "rm -rf out/*"

rule clean_data:
    shell:
        "rm -rf out/data/*"

rule clean_analysis:
    shell:
        "rm -rf out/analysis/*"
```

We can now execute the rule via:

```{r, engine = 'bash', eval = FALSE}
snakemake --cores 1 aug_solow_target
```


## Expanding Multiple Wildcards

The rules used to estimate the standard Solow model and the augmented Solow model are identical except for the model they use:

```{r, engine = 'out', eval = FALSE}

# --- Target Rules --- #

rule solow_target:
    input:
        expand("out/analysis/model_solow_subset_{iSubset}.rds",
                    iSubset = DATA_SUBSET)

rule aug_solow_target:
    input:
        expand("out/analysis/model_aug_solow_subset_{iSubset}.rds",
                    iSubset = DATA_SUBSET)

[...]

rule solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_solow.json",
        subset = "src/data-specs/{iSubset}.json"
    output:
        estimate = "out/analysis/model_solow_subset_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"

rule aug_solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_aug_solow.json",
        subset = "src/data-specs/{iSubset}.json"
    output:
        estimate = "out/analysis/model_aug_solow_subset_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"

[...]
```

We see that the only difference between the `aug_solow_target` and `solow_target` rules is that the filename differs by three letters: `out/analysis/model_aug_solow_{iSubset}.rds` versus
  `out/analysis/model_solow_{iSubset}.rds`.

And, when we look at `aug_solow_model` and compare it to `solow_model` we again see only small differences:
the model changes from `model_aug_solow.json` to `model_solow.json` and the outputs change in a similar way.

We want to exploit this similarity and condense these four rules into two:
one that estimates the model, named `model` and a target rule that will run each specification, names `run_models`.
We are going to do this by creating a new list, called `MODELS`. 
`MODELS` will contain two elements, "model_solow" and "model_aug_solow".
Let's add this to the top of our Snakefile:

```{r, engine = 'out', eval = FALSE}
# --- Dictionaries --- #
MODELS = [
          "model_solow",
          "model_aug_solow"
          ]

DATA_SUBSET = [
                "subset_oecd",
                "subset_intermediate",
                "subset_nonoil"
                ]

PLOTS = [
    "aug_conditional_convergence",
    "conditional_convergence",
    "unconditional_convergence"
]

```

We are now going to delete the target rules `aug_solow_target` and `solow_target`, and the estimation rules 
  `aug_solow_model` and  `solow_model`.
Let's replace them with the following:

```{r, engine = 'out', eval = FALSE}
rule run_models:
    input:
        expand("out/analysis/{iModel}_{iSubset}.rds",
                    iSubset = DATA_SUBSET,
                    iModel = MODELS)

rule model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/{iModel}.json",
        subset = "src/data-specs/{iSubset}.json"
    output:
        estimate = "out/analysis/{iModel}_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"
```

The rule `model` is a generalization of the `solow_model` we had before.
We have added an extra wildcard, `{iModel}` so that the rule can estimate a wider set of models that we specify in the `src/model-specs` folder.
It's `input.model` now takes a wildcard {iModel} and it's output is a `{iModel}` - `{iSubset}` pair.

Similarly, the target rule `run_models` is a generalization of `solow_target`.
Instead of taking only the `model_solow` models as inputs - and looking for how to build those, it now takes any `{iModel}` as an input.
Notice there are now **two** wildcards in the `expand()` function, `{iSubset}` as before, and now also `{iModel}`.
We then naturally have to tell Snakemake which lists to use to expand each wildcard, 
  `DATA_SUBSET` for `{iSubset}`, and
  `MODELS` for `{iModel}`.

Let's clean our output folder and then use Snakemakes `--summary` to see what Snakemake wants to build.
We anticipate it will want to to the data cleaning steps, and then six regression models.
The six regression models will be three each of `model_solow` and `model_aug_solow`.
Each model should be run on each data subset.

```{r, engine = 'out', eval = FALSE}
$ snakemake clean --cores 1
```

```{r, engine = 'out', eval = FALSE}
$ snakemake --summary
```

Here's the output we get:

```{r, engine = 'out', eval = FALSE}
MissingInputException in line 42 of /home/lachlan/teaching/snakemake-econ-r-learner/Snakefile:
Missing input files for rule model:
src/data-specs/oecd.json
src/model-specs/model_solow_subset.json
```

What is going on here?
The problem is as follows:
because our filenames have underscores `_` in them *and* we are using the underscore to separate `{iModel}` and `{iSubset}`
  Snakemake cannot figure out where the first wildcard substitution ends.
We think `model_solow` should be substituted as `{iModel}` and `subset_oecd` should be substituted for `iSubset`.
Unfortunately Snakemake can't handle use of underscores in both file names and wildcard separation simultaneously.

Worry not, there is simple ways around this.
We are going to solve it by separating the wildcards with a period `.` rather than an underscore.^[
 There's other ways to go here.
 You could continue to use underscores but add a few letters inbetween the wildcards and it would also work.
 This means `out/analysis/{iModel}.{iSubset}.rds` would become `out/analysis/{iModel}_SOMETEXT_{iSubset}.rds`.
 It's equally valid.
]
We make this change in both the `model` and `run_models` rules.
This breaks any ambiguity about where a wildcard ends and another begins.
Our updated rules are:

```{r, engine = 'out', eval = FALSE}
rule run_models:
    input:
        expand("out/analysis/{iModel}.{iSubset}.rds",
                    iSubset = DATA_SUBSET,
                    iModel = MODELS)

rule model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/{iModel}.json",
        subset = "src/data-specs/{iSubset}.json"
    output:
        estimate = "out/analysis/{iModel}.{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"
```

Now we again try to get the summary information from Snakemake:

```{r, engine = 'out', eval = FALSE}
$ snakemake --summary
```

There's no longer an error, and instead we see: 

```{r, engine = 'out', eval = FALSE}
output_file     date    rule    version log-file(s)     status  plan
out/analysis/model_solow.subset_oecd.rds        -       -       -       -       missing update pending
out/analysis/model_aug_solow.subset_oecd.rds    -       -       -       -       missing update pending
out/analysis/model_solow.subset_intermediate.rds        -       -       -       -       missing update pending
out/analysis/model_aug_solow.subset_intermediate.rds    -       -       -       -       missing update pending
out/analysis/model_solow.subset_nonoil.rds      -       -       -       -       missing update pending
out/analysis/model_aug_solow.subset_nonoil.rds  -       -       -       -       missing update pending
out/data/mrw_complete.csv       -       gen_regression_vars     -               missing update pending
out/data/mrw_renamed.csv        -       rename_vars     -               missing update pending
```

which confirms that Snakemake wants to do our data cleaning steps before estimating the six regressions.
Let's do it:

```{r, engine = 'out', eval = FALSE}
$ snakemake --cores 1
```

Our Snakemake rule graph - which shows the rules we execute in our workflow is now:

```{r, fig.align="center", echo=FALSE}
knitr::include_graphics("img/ch-5c/rulegraph.pdf")
```

TODO? Some explanation?

And the DAG is:

```{r, fig.align="center", echo=FALSE}
knitr::include_graphics("img/ch-5c/dag.pdf")
```

The DAG makes crystal clear what our workflow is doing:

* Snakemake wants to build the inputs listed in  `run_models`
* It can build those inputs by running the `model` rule six times when it iterates over the wildcards
* To run each model, it needs the clean data, so it needs to run the two data cleaning steps first

!!! REMARK !!!

Notice how the figures aren't produced automatically. 
Do you remember why?
If not, revisit Chapter XX.
You can build them with `snakemake --cores 1 make_figures`

