# Automatic Expansion of Wildcards

## Learning Goals

TODO: Add Goals

TODO:

!!! State of the Snakefile !!!

Add a box with how the snakefile needs to be at the beginning of this chapter

## The `expand()` function

When we look at our target rule:

```{bash, eval = FALSE}
rule solow_target:
    input:
        intermediate = "out/analysis/model_solow_subset_intermediate.rds",
        nonoil       = "out/analysis/model_solow_subset_nonoil.rds",
        oecd         = "out/analysis/model_solow_subset_oecd.rds"
```

We can see that each of inputs listed have similar structure:

* The outputs live on the same path `out/analysis/`, and
* The filenames of each output begin with `model_solow` and end with `.rds`.  

Only the name of the subset of data we are using changing.
We can use the idea of wildcards from the previous chapter together with some additional Snakemake functionality to simplify this target rule.
Using what we learned in Chapter XX, we can modify `solow_target` using a wildcard:

```{bash, eval=FALSE}
rule solow_target:
    input:
        models = "out/analysis/model_solow_{iSubset}.rds",

```

If we try and run snakemake with our target rule written like this we see the following:

```{bash, eval=FALSE}
$ snakemake --cores 1 solow_target
```

We get an error:

```{bash, eval = FALSE}
Building DAG of jobs...
WildcardError in line 12 of /home/lachlan/teaching/snakemake-econ-r-learner/Snakefile:
Wildcards in input files cannot be determined from output files:
'iSubset'
```

Recall that Snakemake won't run a rule that contains a wildcard because it does not know how to resolve it,
i.e. Snakemake doesn't know to replace `{iSubset}` with either of `subset_oecd`, `subset_intermediate` or `subset_nonoil`.
It is our job to tell Snakemake that this is what we want to happen.
Luckily Snakemake has a functionality that allows us to tell it how to accept a wildcard and replace it with a set of specific values.


The function we are looking for is the `expand()` function.
As the name suggests its job is to expand a wildcard by replacing with with a specified value.
All we need to do is tell Snakemake what to substitute in the wildcard's place.
We can use the `expand()` function as follows:

```{bash, eval = FALSE}
rule solow_target:
    input:
        expand("out/analysis/model_solow_{iSubset}.rds",
                    iSubset = DATA_SUBSET)
```

This says replace the wildcard `{iSubset}` with some value `DATA_SUBSET`.
Let's look at the what this buys us.

First, let's clean up our output folder with `snakemake clean` so that we have an clean slate to work with:

```{bash, eval=FALSE}
$ snakemake --cores 1 clean
```

Now replace `DATA_SUBSET` in our target rule of the Snakefile with one of our data subsets the analysis uses, 
  `subset_nonoil`:

```{bash, eval = FALSE}
rule solow_target:
    input:
        expand("out/analysis/model_solow_{iSubset}.rds",
                    iSubset = "subset_nonoil")
```

And let's use the `--summary` option of snakemake to see what the build plan would be:

```{bash, eval=FALSE}
$ snakemake --summary
```

We see:

```{bash, eval=FALSE}
output_file     date    rule    version log-file(s)     status  plan
out/analysis/model_solow_subset_nonoil.rds      -       solow_model     -               missing update pending
out/data/mrw_complete.csv       -       gen_regression_vars     -               missing update pending
out/data/mrw_renamed.csv        -       rename_vars     -               missing update pending
```

From the top line of the output, we can see that Snakemake wants to build the file `out/analysis/model_solow_subset_nonoil.rds`.
This means Snakemake has indeed replaced the wildcard `iSubset` with `subset_nonoil`.
And, because we were not thrown an error message, the problem of not being able to resolve a wildcard has been solved through the use of `expand()`.

Now that we have the idea that `expand()` can replace a wilcard with a value, we want to know how to replace a wildcard with multiple values iteratively,
i.e., first with `subset_nonoil`, then with `subset_oecd` and finally with `subset_intermediate`.
We do this by passing a list, in the python sense of the word, of values that we want {iSubset} to take.
For example, if we want to run the model on both `subset_nonoil` and `subset_oecd`:

```{bash, eval = FALSE}
rule solow_target:
    input:
        expand("out/analysis/model_solow_{iSubset}.rds",
                    iSubset = ["subset_nonoil", "subset_oecd"])
```

If we then look at the summary:

```{bash, eval=FALSE}
$ snakemake --summary
```

We see:

```{bash, eval=FALSE}
output_file     date    rule    version log-file(s)     status  plan
out/analysis/model_solow_subset_nonoil.rds      -       solow_model     -               missing update pending
out/analysis/model_solow_subset_oecd.rds        -       solow_model     -               missing update pending
out/data/mrw_complete.csv       -       gen_regression_vars     -               missing update pending
out/data/mrw_renamed.csv        -       rename_vars     -               missing update pending
```

The top two lines show the wildcard {iSubset} has indeed been replaced successively with `subset_nonoil` and then `subset_oecd`.

The notion of constructing a list of values for Snakemake to iterate through is definitely beneficial, 
  and progress has been made.
However, specifying the list each time in the rule itself is not ideal for at least two reasons:

(i) If we need to use the same list multiple times across different rules we have to copy and paste it, and then be sure we update it correctly each time, and
(ii) It can be hard to find the lists we are iterating over when we read through the Snakefile.

We can easily overcome both limitations by creating our list of data subsets outside of the rule, 
  and then referring the list by name as needed.
To do this, at the top of our Snakefile we will create an area to store lists we will want to iterate through.
For us right now, we want to create a list of data subsets, so let's call the list `DATA_SUBSET`.^[
    The capitalization of the list `DATA_SUBSET` is not essential.
    We do it to separate lists that we will iterate through from other parts of our Snakefile.
    This means whenever we see a capitalized name, we know it is a list that we want to iterate through.
]
Inside that list we put the three subsets:

```{bash, eval=FALSE}
DATA_SUBSET = [
                "subset_oecd",
                "subset_intermediate",
                "subset_nonoil"
                ]
```

Then we inside our `expand()` we write `iSubset = DATA_SUBSET` so Snakemake knows to iterate through that list:

```{bash, eval = FALSE}
rule solow_target:
    input:
        expand("out/analysis/model_solow_{iSubset}.rds",
                    iSubset = DATA_SUBSET)
```

Now when we look at the build plan with the `summary` option:

```{bash, eval=FALSE}
$ snakemake --summary
```

We see:

```{bash, eval=FALSE}
output_file     date    rule    version log-file(s)     status  plan
out/analysis/model_solow_subset_oecd.rds        -       solow_model     -               missing update pending
out/analysis/model_solow_subset_intermediate.rds        -       solow_model     -               missing update pending
out/analysis/model_solow_subset_nonoil.rds      -       solow_model     -               missing update pending
out/data/mrw_complete.csv       -       gen_regression_vars     -               missing update pending
out/data/mrw_renamed.csv        -       rename_vars     -               missing update pending
```

Which shows Snakemake wants to run the regression on all three data subsets.

Let's do that now:

```{bash, eval=FALSE}
$ snakemake --cores 1 
```

!! TO DO !! 

add the output here



### Exercise: Exploring the expand function I {- .exercise}
The MRW paper contains three plots.
Each of these plots use the data subset of 'intermediate' countries.
In the `src/figures/` subdirectory, there are three scripts that reproduce the figures one script per plot.^[
This is not entirely true, we are yet to figure out how to get the y-axis range from the original paper.
]

a) Write three rules `fig_1`, `fig_2` and `fig_3` to produce each figure. 
   Each figure should be saved with the following name 'out/figures/SCRIPTNAME.pdf' 
b) Create a list called `PLOTS` that contains the file names of each of the three plot scripts (without `.R`).
   Use what you have learned about wildcards and the `expand` function to condense the three rules in (a) into 
   one rule `figures` that can make each figure and a target rule `make_figures` so that `snakemake --cores 1 figs_target`
   builds all three figures, one after the other.

HINT:
The scripts are written in such a way that they accept exactly the same options.
Using wildcards and the expand function extend the Snakefile to construct each figure.

### SOLUTION:

Use `snakemake --cores 1 make_figures` to run the figures

```{bash, eval = FALSE}
# --- Dictionaries --- #

DATA_SUBSET = [
                "subset_oecd",
                "subset_intermediate",
                "subset_nonoil"
                ]

PLOTS = [
    "aug_conditional_convergence",
    "conditional_convergence",
    "unconditional_convergence"
]

# --- Build Rules --- #

rule solow_target:
    input:
        expand("out/analysis/model_solow_{iSubset}.rds",
                    iSubset = DATA_SUBSET)

rule solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_solow.json",
        subset = "src/data-specs/{iSubset}.json"
    output:
        estimate = "out/analysis/model_solow_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"


rule make_figures:
    input:
        expand("out/figures/{iFigure}.pdf",
                    iFigure = PLOTS)

rule figure:
    input:
        script = "src/figures/{iFigure}.R",
        data   = "out/data/mrw_complete.csv",
        subset = "src/data-specs/subset_intermediate.json"
    output:
        fig = "out/figures/{iFigure}.pdf"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --subset {input.subset} \
            --out {output.fig}"

rule gen_regression_vars:
    input:
        script = "src/data-management/gen_reg_vars.R",
        data   = "out/data/mrw_renamed.csv",
        param  = "src/data-specs/param_solow.json"
    output:
        data   = "out/data/mrw_complete.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --param {input.param} \
            --out {output.data}"

rule rename_vars:
    input:
        script = "src/data-management/rename_variables.R",
        data   = "src/data/mrw.dta"
    output:
        data = "out/data/mrw_renamed.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --out {output.data}"

rule clean:
    shell:
        "rm -rf out/*"

rule clean_data:
    shell:
        "rm -rf out/data/*"

rule clean_analysis:
    shell:
        "rm -rf out/analysis/*"

```


### Exercise: Exploring the expand() function II {- .exercise}
So far we have estimated the basic Solow model.
MRW also estimate an augmented version of the Solow model, adding human capital.
The regression model required to estimate the augmented model is written up in `src/model-specs/model_aug_solow.json`.

(a) Write the pair of rules `aug_solow_model` and `aug_solow_target` to estimate this model on each of the data subsets in `DATA_SUBSET`

HINT: Use the `expand()` function together with the `estimate_ols.R` script to estimate the augmented solow model on each of the three data subsets.
The rule structures should look very similar to what we have done so far.

### Solution
```{bash, eval = FALSE}
# --- Dictionaries --- #

DATA_SUBSET = [
                "subset_oecd",
                "subset_intermediate",
                "subset_nonoil"
                ]

PLOTS = [
    "aug_conditional_convergence",
    "conditional_convergence",
    "unconditional_convergence"
]

# --- Build Rules --- #

rule solow_target:
    input:
        expand("out/analysis/model_solow_{iSubset}.rds",
                    iSubset = DATA_SUBSET)

rule aug_solow_target:
    input:
        expand("out/analysis/model_aug_solow_{iSubset}.rds",
                    iSubset = DATA_SUBSET)

rule solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_solow.json",
        subset = "src/data-specs/{iSubset}.json"
    output:
        estimate = "out/analysis/model_solow_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"

rule aug_solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_aug_solow.json",
        subset = "src/data-specs/{iSubset}.json"
    output:
        estimate = "out/analysis/model_aug_solow_{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"


rule make_figures:
    input:
        expand("out/figures/{iFigure}.pdf",
                    iFigure = PLOTS)

rule figure:
    input:
        script = "src/figures/{iFigure}.R",
        data   = "out/data/mrw_complete.csv",
        subset = "src/data-specs/subset_intermediate.json"
    output:
        fig = "out/figures/{iFigure}.pdf"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --subset {input.subset} \
            --out {output.fig}"

rule gen_regression_vars:
    input:
        script = "src/data-management/gen_reg_vars.R",
        data   = "out/data/mrw_renamed.csv",
        param  = "src/data-specs/param_solow.json"
    output:
        data   = "out/data/mrw_complete.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --param {input.param} \
            --out {output.data}"

rule rename_vars:
    input:
        script = "src/data-management/rename_variables.R",
        data   = "src/data/mrw.dta"
    output:
        data = "out/data/mrw_renamed.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --out {output.data}"

rule clean:
    shell:
        "rm -rf out/*"

rule clean_data:
    shell:
        "rm -rf out/data/*"

rule clean_analysis:
    shell:
        "rm -rf out/analysis/*"
```


## Expanding Multiple Wildcards

The rules used to estimate the standard Solow model, and the augmented Solow model have very similar structure:

```{r, engine = 'bash', eval = FALSE}
DATA_SUBSET = [
                "oecd",
                "intermediate",
                "nonoil"
                ]

# --- Build Rules --- #
rule run_aug_solow:
    input:
        expand("out/analysis/model_aug_solow_{iSubset}.rds",
                    iSubset = DATA_SUBSET)

rule aug_solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_aug_solow.json",
        subset = "src/data-specs/subset_{iSubset}.json"
    output:
        model_est = "out/analysis/model_aug_solow_{iSubset}.rds",
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.model_est}"

rule run_solow:
    input:
        expand("out/analysis/model_solow_{iSubset}.rds",
                    iSubset = DATA_SUBSET)

rule solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_solow.json",
        subset = "src/data-specs/subset_{iSubset}.json"
    output:
        model_est = "out/analysis/model_solow_{iSubset}.rds",
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.model_est}"
```

Add text ...

Ultimately the Snakfile becomes:

```{r, engine = 'bash', eval = FALSE}
MODELS = [
          "solow",
          "aug_solow"
          ]

DATA_SUBSET = [
                "oecd",
                "intermediate",
                "nonoil"
                ]

# --- Build Rules --- #

rule estimate_models:
    input:
        expand("out/analysis/{iModel}_{iSubset}.rds",
                    iModel = MODELS,
                    iSubset = DATA_SUBSET)

rule ols_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_{iModel}.json",
        subset = "src/data-specs/subset_{iSubset}.json"
    output:
        model_est = "out/analysis/model_{iModel}_{iSubset}.rds",
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.model_est}"

<...> ## Other Rules below
```
