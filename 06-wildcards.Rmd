# Automatic Wildcard Specifications

So far when we have wanted to expand wildcards we have manually specified the values we want them to take.
By doing so, the beginning of our Snakefile looks like this:

```{r, engine = 'bash', eval = FALSE}
MODELS = [
          "solow",
          "aug_solow"
          ]

DATA_SUBSET = [
                "oecd",
                "intermediate",
                "nonoil"
                ]

FIGURES = [
            "aug_conditional_convergence",
            "conditional_convergence",
            "unconditional_convergence"
            ]
```

This is not too problematic when we only have a few values that we want the wildcard to take,
    but manually specifying long lists can get tedious and is prone to error.
Snakemake has a built in function, `glob_wildcards` that will help us to remove the manual listing of values that we have above.

## The `glob_wildcards` Function

Let's start by trying to replace the `MODELS` list that we manually specified with a more automated approach.
The `glob_wildcards` function takes one input - the path of the files that we want to search combined with the part of the file name we want to extract wrapped in parentheses and then finds all files within that path.
Thus, we will replace our original `MODELS` list with:

```{r, engine = 'bash', eval = FALSE}
MODELS = glob_wildcards("src/model-specs/{fname}")
```

To see what happens, let's add a print statement, and then execute a dry-run:
```{r, engine = 'bash', eval = FALSE}
MODELS = glob_wildcards("src/model-specs/{fname}")
print(MODELS)
```
then:
```{r, engine = 'bash', eval = FALSE}
$ snakemake --dryrun
```

What we are interested in is the first printed lines (in white text):
```{r, engine = 'out', eval = FALSE}
Wildcards(fname=['.gitkeep', 'model_solow.json', 'model_aug_cc_restr.json',
                'model_solow_restr.json', 'model_cc.json', 'model_ucc.json',
                'model_aug_solow_restr.json', 'model_aug_cc.json', 'model_aug_solow.json'])
```

Here we see that all filed are returned.
Compared to our original `MODELS` list we see three differences

1. There are more .json files
2. There is a .gitkeep file
3. Each 'fname' ends with .json, which we did't have earlier.

(1) is not a problem, it reflects that there is more potential analysis files that we havent manually specified.
But (2) and (3) are problematic.
We can remove the .gitkeep file *and* the .json file endings with one step:
telling the `glob_wildcards` function to only return the part of the filename that comes before the .json.
This will also mean that the .gitkeep is not returned, because this file does not have a .json ending:

```{r, engine = 'bash', eval = FALSE}
MODELS = glob_wildcards("src/model-specs/{fname}.json")
print(MODELS)
```
then:
```{r, engine = 'bash', eval = FALSE}
$ snakemake --dryrun
```
Now the first line is:
```{r, engine = 'out', eval = FALSE}
Wildcards(fname=['model_solow', 'model_aug_cc_restr',
                'model_solow_restr', 'model_cc', 'model_ucc',
                'model_aug_solow_restr', 'model_aug_cc', 'model_aug_solow'])
```

That's definitely an improvement.
Our final step is to extract the list called `fname` so that we can use it like our old `MODELS` list.
We do this as follows:
```{r, engine = 'bash', eval = FALSE}
MODELS = glob_wildcards("src/model-specs/{fname}.json").fname
```

Now if we do a dry-run we are returned the following:

```{r, engine = 'out', eval = FALSE}
['model_solow', 'model_aug_cc_restr', 'model_solow_restr',
 'model_cc', 'model_ucc', 'model_aug_solow_restr',
 'model_aug_cc', 'model_aug_solow']
```
which has the same structure as before.

Now if we run snakemake:
```{r, engine = 'bash', eval = FALSE}
$ snakemake
```
We see that it builds the OLS estimates of the models that we have not yet previously run^[
    Running `snakemake estimate_models --force` will run all of the models including those that we have constructed in previous chapters.
]

### Exercise: Exploring glob_wildcards() {- .exercise}

Use the `glob_wildcards` function to automate the construction of the `FIGURES` list.
Rememeber that depending on the order of your Snakemake rules, you may need to explicitly call the rule that generates figures to run the code, i.e. `snakemake make_figs`.

## Further Restricting the `glob_wildcards` output

So far, we have used `glob_wildcards` output unchanged.
Sometimes the lists that it returns might have found more files than we desire, or some of the files might be used in different ways than others.
We are now going to show a simple way to filter out unwanted elements of the list that `glob_wildcards` returns.

So far, we still have one list of wildcards that we have manually specified, `DATA_SUBSET`:
```{r, engine = 'bash', eval = FALSE}
MODELS = glob_wildcards("src/model-specs/{fname}.json").fname

DATA_SUBSET = [
                "oecd",
                "intermediate",
                "nonoil"
                ]

FIGURES = glob_wildcards("src/figures/{fname}.json").fname
```

Let's start by looking at the output if we run `glob_wildcards` as we have before:
```{r, engine = 'bash', eval = FALSE}
MODELS = glob_wildcards("src/model-specs/{fname}.json").fname

DATA_SUBSET = glob_wildcards("src/data-specs/{fname}.json").fname
print(DATA_SUBSET)

FIGURES = glob_wildcards("src/figures/{fname}.json").fname
```

and doing a dry run to examine the output of the print statement:
```{r, engine = 'bash', eval = FALSE}
$ snakemake --dryrun
```
which yields:
```{r, engine = 'out', eval = FALSE}
['param_solow', 'subset_oecd', 'subset_nonoil', 'subset_intermediate']
```

In this list, the `param_solow` element is the odd one out.
It is used in the data cleaning part, and does not contain a filter that can be applied to a data frame.
The question is then how do we remove it?
What we need to is complete the following steps:

1. identify a pattern that we can use to filter out `param_solow`
    * Files we want to keep all start with 'subset'
2. write a function that would remove it from the list
    * `lambda x: x.startswith("subset")`
3. use this function to filter the out param_solow from DATA_SUBSET
    * `filter(lambda x: x.startswith("subset"), DATA_SUBSET))`
4. Take the new output as a list
    * `list(filter(lambda x: x.startswith("subset"), DATA_SUBSET)))`

We can do this all by adding one additional line:
```{r, engine = 'bash', eval = FALSE}
DATA_SUBSET = glob_wildcards("src/data-specs/{fname}.json").fname
DATA_SUBSET = list(filter(lambda x: x.startswith("subset"), DATA_SUBSET)))
print(DATA_SUBSET)
```
Now again doing a dry-run with `snakemake --dryrun` we see the first line prints out the new DATA_SUBSET list as:
```{r, engine = 'out', eval = FALSE}
['subset_oecd', 'subset_nonoil', 'subset_intermediate']
```
Which is the desired output.

We can now run snakemake and see if it wants to execute any of our rules
```
snakemake --summary
```
and we see that it does not. Can you explain why?
