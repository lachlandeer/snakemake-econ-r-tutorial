# Automating List Construction for Wildcard Expansion

## Learning Objectives

TODO!

## State of the Snakefile

TODO: Make this a box + code fold

To proceed with this chapter, we expect you Snakefile to look as follows:

```{bash, eval = FALSE}
# --- Dictionaries --- #

MODELS = [
          "model_solow",
          "model_aug_solow"
          ]

DATA_SUBSET = [
                "subset_oecd",
                "subset_intermediate",
                "subset_nonoil"
                ]

PLOTS = [
    "aug_conditional_convergence",
    "conditional_convergence",
    "unconditional_convergence"
]

# --- Build Rules --- #

rule run_models:
    input:
        expand("out/analysis/{iModel}.{iSubset}.rds",
                    iSubset = DATA_SUBSET,
                    iModel = MODELS)

rule model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/{iModel}.json",
        subset = "src/data-specs/{iSubset}.json"
    output:
        estimate = "out/analysis/{iModel}.{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"

rule make_figures:
    input:
        expand("out/figures/{iFigure}.pdf",
                    iFigure = PLOTS)


rule figure:
    input:
        script = "src/figures/{iFigure}.R",
        data   = "out/data/mrw_complete.csv",
        subset = "src/data-specs/subset_intermediate.json"
    output:
        fig = "out/figures/{iFigure}.pdf"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --subset {input.subset} \
            --out {output.fig}"


rule gen_regression_vars:
    input:
        script = "src/data-management/gen_reg_vars.R",
        data   = "out/data/mrw_renamed.csv",
        param  = "src/data-specs/param_solow.json"
    output:
        data   = "out/data/mrw_complete.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --param {input.param} \
            --out {output.data}"

rule rename_vars:
    input:
        script = "src/data-management/rename_variables.R",
        data   = "src/data/mrw.dta"
    output:
        data = "out/data/mrw_renamed.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --out {output.data}"


rule clean:
    shell:
        "rm -rf out/*"

rule clean_data:
    shell:
        "rm -rf out/data/*"

rule clean_analysis:
    shell:
        "rm -rf out/analysis/*"
```


So far when we have wanted to expand wildcards we have manually specified the values we want them to take.
By doing so, the beginning of our Snakefile looks like this:

```{r, engine = 'bash', eval = FALSE}
MODELS = [
          "solow",
          "aug_solow"
          ]

DATA_SUBSET = [
                "oecd",
                "intermediate",
                "nonoil"
                ]

FIGURES = [
            "aug_conditional_convergence",
            "conditional_convergence",
            "unconditional_convergence"
            ]
```

This is not too problematic when we only have a few values that we want the wildcard to take,
    but manually specifying long lists can get tedious and is prone to error.
Snakemake has a built in function, `glob_wildcards` that will help us to remove the manual listing of values that we have above.

## The `glob_wildcards` Function

Let's start by trying to replace the `MODELS` list that we manually specified with a more automated approach.
The `glob_wildcards` function takes one input - the path of the files that we want to search combined with the part of the file name we want to extract wrapped in parentheses and then finds all files within that path.
Thus, we will replace our original `MODELS` list with:

```{r, engine = 'bash', eval = FALSE}
MODELS = glob_wildcards("src/model-specs/{fname}")
```

To see what happens, let's add a print statement, and then execute a dry-run:
```{r, engine = 'bash', eval = FALSE}
MODELS = glob_wildcards("src/model-specs/{fname}")
print(MODELS)
```
then:
```{r, engine = 'bash', eval = FALSE}
$ snakemake --dryrun
```

What we are interested in is the first printed lines (in white text):
```{r, engine = 'out', eval = FALSE}
Wildcards(fname=['.gitkeep', 'model_solow.json', 'model_aug_cc_restr.json',
                'model_solow_restr.json', 'model_cc.json', 'model_ucc.json',
                'model_aug_solow_restr.json', 'model_aug_cc.json', 'model_aug_solow.json'])
```

Here we see that all filed are returned.
Compared to our original `MODELS` list we see three differences

1. There are more .json files
2. There is a .gitkeep file
3. Each 'fname' ends with .json, which we did't have earlier.

(1) is not a problem, it reflects that there is more potential analysis files that we havent manually specified.
But (2) and (3) are problematic.
We can remove the .gitkeep file *and* the .json file endings with one step:
telling the `glob_wildcards` function to only return the part of the filename that comes before the .json.
This will also mean that the .gitkeep is not returned, because this file does not have a .json ending:

```{r, engine = 'bash', eval = FALSE}
MODELS = glob_wildcards("src/model-specs/{fname}.json")
print(MODELS)
```
then:
```{r, engine = 'bash', eval = FALSE}
$ snakemake --dryrun
```
Now the first line is:
```{r, engine = 'out', eval = FALSE}
Wildcards(fname=['model_solow', 'model_aug_cc_restr',
                'model_solow_restr', 'model_cc', 'model_ucc',
                'model_aug_solow_restr', 'model_aug_cc', 'model_aug_solow'])
```

That's definitely an improvement.
Our final step is to extract the list called `fname` so that we can use it like our old `MODELS` list.
We do this as follows:
```{r, engine = 'bash', eval = FALSE}
MODELS = glob_wildcards("src/model-specs/{fname}.json").fname
```

Now if we do a dry-run we are returned the following:

```{r, engine = 'out', eval = FALSE}
['model_solow', 'model_aug_cc_restr', 'model_solow_restr',
 'model_cc', 'model_ucc', 'model_aug_solow_restr',
 'model_aug_cc', 'model_aug_solow']
```
which has the same structure as before.

Now if we run snakemake:
```{r, engine = 'bash', eval = FALSE}
$ snakemake
```
We see that it builds the OLS estimates of the models that we have not yet previously run^[
    Running `snakemake estimate_models --force` will run all of the models including those that we have constructed in previous chapters.
]

### Exercise: Exploring glob_wildcards() {- .exercise}

Use the `glob_wildcards` function to automate the construction of the `FIGURES` list.
Rememeber that depending on the order of your Snakemake rules, you may need to explicitly call the rule that generates figures to run the code, i.e. `snakemake make_figs`.

