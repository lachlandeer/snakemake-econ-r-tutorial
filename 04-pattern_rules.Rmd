# Pattern Rules

## Where we are now?

Your Snakefile should look something like this:

```{r, engine = 'bash', eval = FALSE}
## Snakemake - MRW Replication
##
## @yourname


# --- Build Rules --- #

rule solow_intermediate:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_solow.json",
        subset = "src/data-specs/subset_intermediate.json"
    output:
        model_est = "out/analysis/model_solow_subset_intermediate.rds",
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.model_est}"

rule solow_nonoil:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_solow.json",
        subset = "src/data-specs/subset_nonoil.json"
    output:
        model_est = "out/analysis/model_solow_subset_nonoil.rds",
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.model_est}"

rule solow_oecd:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_solow.json",
        subset = "src/data-specs/subset_oecd.json"
    output:
        model_est = "out/analysis/model_solow_subset_oecd.rds",
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.model_est}"

rule gen_regression_vars:
    input:
        script = "src/data-management/gen_reg_vars.R",
        data   = "out/data/mrw_renamed.csv",
        params = "src/data-specs/param_solow.json",
    output:
        data = "out/data/mrw_complete.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --param {input.params} \
            --out {output.data}"

rule rename_vars:
    input:
        script = "src/data-management/rename_variables.R",
        data   = "src/data/mrw.dta"
    output:
        data = "out/data/mrw_renamed.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --out {output.data}"

# --- Clean Rules --- #
rule clean:
    shell:
        "rm -rf out/*"
```

This is good progress, but if we look at the *solow_* rules we see that there is quite a lot of duplication:

* Detail the duplication here

## Wildcards

Ideally, we want our Snakefiles to feature the miniumum amount of duplication possible (Why?).
The three *solow_* rules can be collapsed into one rule if can create a variable, for example `iSubset`,
    that can iterate through the three .json files that contain the subset filters.
That is, we want to create a rule `solow_model` that can do the work that `solow_nonoil`, `solow_oecd` and `solow_intermediate` currently do.
In Snakemake, these variables are called *wildcards*.

The format of this rule will be:

```{r, engine = 'bash', eval = FALSE}
rule solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_solow.json",
        subset = "src/data-specs/subset_{iSubset}.json"
    output:
        model_est = "out/analysis/model_solow_{iSubset}.rds",
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.model_est}"
```

We wrapped our wildcard `iSubset` in curly parentheses so that Snakemake knows that we will want to substitute the name of one of the subsets into this value.
This is conceptually similar to what we have done in our shell commands.

We can now try and run our updated Snakefile:

```{r, engine = 'bash', eval= FALSE}
$ snakemake
```

```{r, engine = 'out', eval = FALSE}
Building DAG of jobs...
WorkflowError:
Target rules may not contain wildcards. Please specify concrete files or a rule without wildcards.
```

What has happened?
Snakemake will not execute a rule that contains wildcards.^[
Technically there is another problem here too.
Snakemake doesn't know what values to substitute into `iSubset.`
We focus on the Wildcard error because this is what the Snakemake error message mentions.
By fixing this error, it turns out we also spell out what values to substitute into `iSubset`.
]
What we will do is create another rule, `run_solow` that will not contain wildcards ...

```{r, engine = 'bash', eval = FALSE}

rule run_solow:
    input:
        nonoil = "out/analysis/model_solow_nonoil.rds",
        oecd   = "out/analysis/model_solow_oecd.rds",
        intermediate = "out/analysis/model_solow_intermediate.rds"

rule solow_model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/model_solow.json",
        subset = "src/data-specs/subset_{iSubset}.json"
    output:
        model_est = "out/analysis/model_solow_{iSubset}.rds",
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.model_est}"
```

Explain what happens here...

There's more work we can do to reduce duplication.
Look at the rule `run_solow`:

```{r, engine = 'bash', eval = FALSE}
rule run_solow:
    input:
        nonoil = "out/analysis/model_solow_nonoil.rds",
        oecd   = "out/analysis/model_solow_oecd.rds",
        intermediate = "out/analysis/model_solow_intermediate.rds"
```

## The `expand()` function

Each of these inputs listed above have similar structure, with only the name of the subset of data we are using changing.
We can use another feature of Snakemake to simplify this rule.
Snakemake has an `expand()` function that can accept a wildcard and replace it with a set of specified values in an iterative manner.
In our case, we want to use the expand function to accept the `{iSubset}` wildcard, and replace it with the values 'nonoil', 'oecd' and 'intermediate' one at a time.
To proceed we need to do two things:

1. Create a list, DATA_SUBSETS, that contains the values we want to iterate through - 'nonoil', 'oecd' and 'intermediate'.
2. Use Snakemake's `expand()` function to iteratively replace `{iSubset}` with each value contained in the list `DATA_SUBSET`

Let's start with (1).
We will use an area above our Snakemake rules to store the `DATA_SUBSET` variable:

```{r, engine = 'bash', eval = FALSE}
DATA_SUBSET = [
                "oecd",
                "intermediate",
                "nonoil"
                ]

# --- Build Rules --- #
...
```

The capitalization of the list DATA_SUBSET is not essential.
We do it to separate lists that we will iterate through from other parts of our Snakefile.
This means whenever we see a capitalized name, we know it is a list that we want to iterate through.

Next, we update the rule `run_solow` as follows:

```{r, engine = 'bash', eval = FALSE}
rule run_solow:
    input:
        expand("out/analysis/model_solow_{iSubset}.rds",
                    iSubset = DATA_SUBSET)
```

Now, we can clean our output folder with `$ snakemake clean`.
If we re-run snakemake we would expect everything to run.
To see if this is the case we can do a *dry run*.
A dry run will try go through the Snakefile and print all the rules Snakemake wants to execute in order.

```{r, engine = 'bash', eval = FALSE}
$ snakemake --dryrun
```

which yields the following plan:

```{r, engine = 'out', eval = FALSE}
Building DAG of jobs...
Job counts:
	count	jobs
	1	gen_regression_vars
	1	rename_vars
	1	run_solow
	3	solow_model
	6

[Fri Jan 11 17:00:32 2019]
rule rename_vars:
    input: src/data/mrw.dta, src/data-management/rename_variables.R
    output: out/data/mrw_renamed.csv
    jobid: 5


[Fri Jan 11 17:00:32 2019]
rule gen_regression_vars:
    input: out/data/mrw_renamed.csv, src/data-management/gen_reg_vars.R, src/data-specs/param_solow.json
    output: out/data/mrw_complete.csv
    jobid: 4


[Fri Jan 11 17:00:32 2019]
rule solow_model:
    input: src/data-specs/subset_nonoil.json, out/data/mrw_complete.csv, src/model-specs/model_solow.json, src/analysis/estimate_ols_model.R
    output: out/analysis/model_solow_nonoil.rds
    jobid: 1
    wildcards: iSubset=nonoil


[Fri Jan 11 17:00:32 2019]
rule solow_model:
    input: src/data-specs/subset_oecd.json, out/data/mrw_complete.csv, src/model-specs/model_solow.json, src/analysis/estimate_ols_model.R
    output: out/analysis/model_solow_oecd.rds
    jobid: 2
    wildcards: iSubset=oecd


[Fri Jan 11 17:00:32 2019]
rule solow_model:
    input: src/data-specs/subset_intermediate.json, out/data/mrw_complete.csv, src/model-specs/model_solow.json, src/analysis/estimate_ols_model.R
    output: out/analysis/model_solow_intermediate.rds
    jobid: 3
    wildcards: iSubset=intermediate


[Fri Jan 11 17:00:32 2019]
localrule run_solow:
    input: out/analysis/model_solow_nonoil.rds, out/analysis/model_solow_oecd.rds, out/analysis/model_solow_intermediate.rds
    jobid: 0

Job counts:
	count	jobs
	1	gen_regression_vars
	1	rename_vars
	1	run_solow
	3	solow_model
	6

```

This looks like what we want to happen.
Hence, we re-run snakemake to produce all output:

```{r, engine = 'bash', eval = FALSE}
$ snakemake
```
