# Initial Steps with Snakemake

## Starting a Research Project

We are now ready to get started working with the code and data to build a fully reproducible pipeline.
In Chapter XX we described a simplified research workflow to be:

1. Perform some data management
2. Do some analysis
3. Turn the output of the analysis into a tabular format
4. Construct a set of graphs
5. Integrate the tables and graphs into a paper and a set of slides (optional)

We are going to start at the beginning with data management.

Recall that we have the following files in our data management subdirectory, `src/data-management`:

```{r datamgt-scripts, engine = 'out', eval = FALSE}
rename_variables.R
gen_reg_vars.R
```

We will need to run each of these scripts sequentially.
First we want to run the script `rename_variables.R` to tidy up the variable names in our data set.
Second, `gen_reg_vars.R` will create the some additional variables in our data that will be needed to run some regressions in later steps.
Over the next few sections we are going to build up 2 **rules**, one for each file, that will execute these scripts and deliver output.

## The Beginning of a Snakefile

We are going to put the collection of rules that build our project into a file.
We can then use the `Snakemake` to execute these rules and build our project.
The set of rules we want to construct are going to go into the file called `Snakefile` - which is the name of a file that Snakemake will look into by default to execite a project.
Lets open the file called `Snakefile` in the project's main directory.
When you open it it should look as follows:

```{r snakefile-start, engine = 'bash', eval = FALSE}
# Main Workflow - SOME PROJECT
#
# Contributors: YOUR NAME(S)
```

Note that the amount of structure we have here is not totally necessary.
However, good structure will make understanding easier later.
Let's go through what we see.
The first lines of code are comments, to help us navigate a little and understand what we are looking at.
The very first line tells us that this is a project workflow, and then tells us what the particular project is.
The second line tells us who contributed to this file.
This can be useful so we know who to contact with questions.
You should do update the name of the project, and add your name to the list of contributors.
For us, the top 2 lines becomes:

```{r snakefile-start-2, engine = 'bash', eval = FALSE}
# Main Workflow - MRW Replication
#
# Contributors: @lachlandeer, @julianlanger
```

The next few lines are:

```{r snakefile-start-3, engine = 'bash', eval = FALSE}
# --- Main Build Rules --- #
## To be constructed
```

These are more comments.
We are using the `# --- Something --- #` notation to break up the code into logical blocks.
It is in this block that we will assemble the rules on which our project will be built.

## Rule Structure

A `Snakefile` is a collection of rules that together define the order in which a project will be executed.
In our `Snakefile` we will start to assemble rules under the `# --- Main Build Rules --- #` section to keep things tidy.
Each rule can be thought of as a recipe that combines different **inputs**, such as data and and R script together to produce one or more **output(s)**.
The key components we are going to use to construct a rule are:

(i) a name for the rule,
(ii) the list of inputs
(iii) the list of outputs produced
(iv) a shell command that tells snakemake how to combine the inputs to produce a outputs.

`Snakemake` expects these components to be provided in a particular way so that it knows what to do with the information you provided.
We are going to specify rules in the following format:

```{r snakefile-rule-str, engine = 'bash', eval = FALSE}
rule rule_name:
    input:
        input_name1 = "PATH/TO/input_one",
        input_name2 = "PATH/TO/input_two"
    output:
        output_name1 = "PATH/TO/SAVE/output_one",
        output_name2 = "PATH/TO/SAVE/output_two"
    shell:
        "HOW TO MIX IT ALL TOGETHER"
```

We can have as many inputs and outputs as we need to have per rule.
Each input and each output are given names, for example `input_name1` which take the value to the file path and name of the file.
It is important to wrap each of these paths into quotations, and to separate each of the multiple inputs and outputs with a comma.

## Our First Rule


### Constructing the Rule
As mentioned above, we will start with the data management step.

First script to run is `rename_variables.R` which is located in the data management subdirectory.
This is a simple script that renames some variables for us to be easier to understand.

We can then start our snakemake script by adding this script as an input:

```{r rename-vars, engine = 'bash', eval = FALSE}
rule rule_name:
    input:
        script = "src/data-management/rename_variables.R",
        input_name2 = "PATH/TO/input_two"
    output:
        output_name1 = "PATH/TO/SAVE/output_one",
        output_name2 = "PATH/TO/SAVE/output_two"
    shell:
        "HOW TO MIX IT ALL TOGETHER"
```

Next, we want to add any additional inputs and also specify any outputs that the file produces.
We have set up all R scripts in this example to provide us with 'help' so that we know what we might need to add.
To find out what inputs are required and what outputs are produced, we use the `--help` flag when calling the file with `R`:

```{r rename-vars-2, engine = 'bash', eval = FALSE}
$ Rscript src/data-management/rename_variables.R --help
```

And the following output is produced:

```{r rename-vars-3, engine = 'out', eval = FALSE}
Usage: src/data-management/rename_variables.R [options]


Options:
	-d CHARACTER, --data=CHARACTER
		stata dataset file name

	-o CHARACTER, --out=CHARACTER
		output file name [default = out.csv]

	-h, --help
		Show this help message and exit
```

This suggests the script needs ...

We update our `rename_variables` as:

```{r rename-vars-4, engine = 'bash', eval = FALSE}
rule rename_vars:
    input:
        script = "src/data-management/rename_variables.R",
        data   = "src/data/mrw.dta"
    output:
        data = "out/data/mrw_renamed.csv"
    shell:
        "HOW TO MIX IT ALL TOGETHER"
```

Next we provide a recipe telling snakemake how to mix the inputs to create the outputs:

```{r rename-vars-5, engine = 'bash', eval = FALSE}
rule rename_vars:
    input:
        script = "src/data-management/rename_variables.R",
        data   = "src/data/mrw.dta"
    output:
        data = "out/data/mrw_renamed.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --out {output.data}"
```

We can now try and run snakemake to execute this rule ...

```{r rename-vars-6, engine = 'bash', eval = FALSE}
$ snakemake
```

Stuff happens ...

### Analysing Output

We can look into our output directory to see if anything has happened:

```{r, engine = 'bash', eval = FALSE}
$ ls out/data/
```
which yields

```{r, engine = 'out', eval=FALSE}
mrw_renamed.csv
```

Our file has been created as we expected.

Try and run snakemake again
```{r, engine = 'bash', eval = FALSE}
$ snakemake
```

and we see the following output:

```{r, engine = 'out', eval = FALSE}
Building DAG of jobs...
Nothing to be done.
```

Why?

Snakemake provides the a *summary* option which tells us what is going on:
```{r, engine = 'bash', eval = FALSE}
snakemake --summary
```

The output is:
```{r, engine = 'out', eval = FALSE}
Building DAG of jobs...
output_file	                      date	                  rule	    version	 log-file(s)	status	plan
out/data/mrw_renamed.csv	Thu Jan 10 20:31:08 2019	rename_vars	   -		             ok	    no update

```

Explain what this tells us ...

Suppose we updated one of the inputs ...

```{r, engine = 'bash', eval = FALSE}
$ touch src/data-management/rename_variables.R
```

and then look at the summary from snakemake:

```{r, engine = 'bash', eval = FALSE}
$ snakemake
```

```{r, engine = 'out', eval = FALSE}
Building DAG of jobs...
output_file	                       date	                   rule	    version	log-file(s)	     status	               plan
out/data/mrw_renamed.csv	Thu Jan 10 20:31:08 2019	rename_vars	   -		        updated input files	update pending
```

What this means?

Run snakemake to build the output:

```
snakemake
```

### Exercise: Deleting Output {- .exercise}
Delete the output `out/data/mrw_renamed.csv`.
Run `snakemake --summary` and explain the output it produced.

## Creating a Second Rule

The second step in our data management is to create some variables we will use in our regression analysis.
The script `gen_reg_vars.R` in the `src/data-management` folder does this for us.
We are going to build a rule called `gen_regression_vars` to do this in Snakemake.
Let's see what the script expects to be passed:

```{r, engine = 'bash', eval = FALSE}
$ Rscript src/data-management/gen_reg_vars.R --help
```

```{r, engine = 'out', eval = FALSE}
Usage: src/data-management/gen_reg_vars.R [options]


Options:
	-d CHARACTER, --data=CHARACTER
		a csv file name

	-p CHARACTER, --param=CHARACTER
		a file name containing model parameters

	-o CHARACTER, --out=CHARACTER
		output file name [default = out.csv]

	-h, --help
		Show this help message and exit

```

So we need to provide:

to provide the output ...

Let's create this rule:

```{r, engine = 'bash', eval = FALSE}
rule gen_regression_vars:
    input:
        script = "src/data-management/gen_reg_vars.R",
        data   = "out/data/mrw_renamed.csv",
        params = "src/data-specs/param_solow.json",
    output:
        data = "out/data/mrw_complete.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --param {input.params} \
            --out {output.data}"
```

What will Snakemake want to do next? Let's use the summary option to see ...

```{r, engine = 'bash', eval = FALSE}
$ snakemake --summary
```

```{r, engine = 'out', eval = FALSE}
Building DAG of jobs...
output_file	                   date	                    rule	              version	log-file(s)	status	   plan
out/data/mrw_complete.csv	-	                        gen_regression_vars	    -		            missing	update pending
out/data/mrw_renamed.csv	Fri Jan 11 13:40:07 2019	rename_vars	            -		            ok	        no update
```

Explain what this means

Let's run snakemake to build our new file:

```{r, engine = 'bash', eval = FALSE}
$ snakemake
```

When we look at our output directory:

```{r, engine = 'bash', eval = FALSE}
$ ls out/data/
```

```{r, engine = 'out', eval = FALSE}
mrw_complete.csv  mrw_renamed.csv
```

So we see that our data set has been built.

### Exercise: Creating Rules {- .exercise}
The MRW paper estimates the Solow model for three subsets of data.
You need to create rules to do estimate the Solow model for each of these data sets.
The R script `src/analysis/estimate_ols.R` will estimate a OLS model for a given dataset when you provide the necessary inputs.

1. What inputs do you need to provide?
2. What outputs will be produced?
3. Write Snakemake rules to estimate the solow model for each subset of data.

## Clean Rules

So far, we have built up our Snakefile to:

1. Clean data
2. Run a regression model on different subsets of data

As we continue to extend our Snakefile in the coming chapters we might want to be able to delete all of the produced outputs, and see if we can rebuild our project from the first step.
One way to do this would be to go to our terminal window and enter the following command each time:

```{r, engine = 'bash', eval = FALSE}
$ rm -rf out/*
```

Instead of doing this each time, we can integrate this *cleaning* of computer produced outputs into our Snakefile.
We can create a rule called `clean` that stores the shell command from above:

```{r, engine = 'bash', eval = FALSE}
rule clean:
    shell:
        "rm -rf out/*"
```

Note that this rule has no inputs or outputs.

To use this rule, we enter the following into our terminal:
```{r, engine = 'bash', eval = FALSE}
$ snakemake clean
```

Notice that to use the clean rule we had to call the rule name, clean, explicitly.

Now if we look out the output of running the summary call with snakemake, we see the following output:

```{r, engine = 'bash', eval = FALSE}
snakemake --summary
```

```{r, engine = 'out', eval = FALSE}
Building DAG of jobs...
output_file	                                       date	  rule	version	log-file(s)	    status	plan
out/analysis/model_solow_subset_intermediate.rds	-	  inter	       -    	        missing	update pending
out/analysis/model_solow_subset_nonoil.rds	        -	  nonoil       -	            missing	update pending
out/analysis/model_solow_subset_oecd.rds	        -	  oecd	       -	            missing	update pending
out/data/mrw_complete.csv	                        -	  gen_regression_vars   		missing	update pending
out/data/mrw_renamed.csv	                        -	  rename_vars	          		missing	update pending
```

Which reveals snakemake's plan the next time its run will be to build all outputs.

### Exercise: Creating Cleaning Rules {- .exercise}
So far we have written a cleaning rule that deletes everything in the `out/` directory.
Construct rules that would separately clean the `out/data/` and `out/analysis` subdirectories.
Why might we want to do this?
