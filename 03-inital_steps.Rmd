# Initial Steps with Snakemake

## Starting a Research Project

We are now ready to get started working with the code and data to build a fully reproducible pipeline.
In Chapter XX we described a simplified research workflow to be:

1. Perform some data management
2. Do some analysis
3. Turn the output of the analysis into a tabular format
4. Construct a set of graphs
5. Integrate the tables and graphs into a paper and a set of slides (optional)

We are going to start at the beginning with data management.

Recall that we have the following files in our data management subdirectory, `src/data-management`:

```{r datamgt-scripts, engine = 'bash', eval = FALSE}
rename_variables.R
gen_reg_vars.R
```

We will need to run each of these scripts sequentially.
First we want to run the script `rename_variables.R` to tidy up the variable names in our data set.
Second, `gen_reg_vars.R` will create the some additional variables in our data that will be needed to run some regressions in later steps.
Over the next few sections we are going to build up 2 **rules**, one for each file, that will execute these scripts and deliver output.

## The Beginning of a Snakefile

We are going to put the collection of rules that build our project into a file.
We can then use the `Snakemake` to execute these rules and build our project.
The set of rules we want to construct are going to go into the file called `Snakefile` - which is the name of a file that Snakemake will look into by default to execite a project.
Lets open the file called `Snakefile` in the project's main directory.
When you open it it should look as follows:

```{r snakefile-start, engine = 'bash', eval = FALSE}
# Main Workflow - SOME PROJECT
#
# Contributors: YOUR NAME(S)
```

Note that the amount of structure we have here is not totally necessary.
However, good structure will make understanding easier later.
Let's go through what we see.
The first lines of code are comments, to help us navigate a little and understand what we are looking at.
The very first line tells us that this is a project workflow, and then tells us what the particular project is.
The second line tells us who contributed to this file.
This can be useful so we know who to contact with questions.
You should do update the name of the project, and add your name to the list of contributors.
For us, the top 2 lines becomes:

```{r snakefile-start-2, engine = 'bash', eval = FALSE}
# Main Workflow - MRW Replication
#
# Contributors: @lachlandeer, @julianlanger
```

The next few lines are:

```{r snakefile-start-3, engine = 'bash', eval = FALSE}
# --- Main Build Rules --- #
## To be constructed
```

These are more comments.
We are using the `# --- Something --- #` notation to break up the code into logical blocks.
It is in this block that we will assemble the rules on which our project will be built.

## Rule Structure

A `Snakefile` is a collection of rules that together define the order in which a project will be executed.
In our `Snakefile` we will start to assemble rules under the `# --- Main Build Rules --- #` section to keep things tidy.
Each rule can be thought of as a recipe that combines different **inputs**, such as data and and R script together to produce one or more **output(s)**.
The key components we are going to use to construct a rule are:

(i) a name for the rule,
(ii) the list of inputs
(iii) the list of outputs produced
(iv) a shell command that tells snakemake how to combine the inputs to produce a outputs.

`Snakemake` expects these components to be provided in a particular way so that it knows what to do with the information you provided.
We are going to specify rules in the following format:

```{r snakefile-rule-str, engine = 'bash', eval = FALSE}
rule rule_name:
    input:
        input_name1 = "PATH/TO/input_one",
        input_name2 = "PATH/TO/input_two"
    output:
        output_name1 = "PATH/TO/SAVE/output_one",
        output_name2 = "PATH/TO/SAVE/output_two"
    shell:
        "HOW TO MIX IT ALL TOGETHER"
```

We can have as many inputs and outputs as we need to have per rule.
Each input and each output are given names, for example `input_name1` which take the value to the file path and name of the file.
It is important to wrap each of these paths into quotations, and to separate each of the multiple inputs and outputs with a comma.

## Our First Rule
