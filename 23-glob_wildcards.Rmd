# Automated Wildcard Lists

:::{- .objectives} 
### Overview {-}

**Questions**

- Do you we have to define lists by hand?
- Can Snakemake help us create lists automatically?

**Objectives**

- Learn how to create wildcards from files in the project folder
- Explain what the `glob_wildcard()` function is and how to ues it

:::

:::{- .prereq}
### Snakefile Status {-}

To proceed with this chapter, we expect you Snakefile to look as follows:

```{r, engine = 'bash', eval = FALSE}
# --- Dictionaries --- #

MODELS = [
          "model_solow",
          "model_aug_solow"
          ]

DATA_SUBSET = [
                "subset_oecd",
                "subset_intermediate",
                "subset_nonoil"
                ]

PLOTS = [
    "aug_conditional_convergence",
    "conditional_convergence",
    "unconditional_convergence"
]

# --- Build Rules --- #

rule run_models:
    input:
        expand("out/analysis/{iModel}.{iSubset}.rds",
                    iSubset = DATA_SUBSET,
                    iModel = MODELS)

rule model:
    input:
        script = "src/analysis/estimate_ols_model.R",
        data   = "out/data/mrw_complete.csv",
        model  = "src/model-specs/{iModel}.json",
        subset = "src/data-specs/{iSubset}.json"
    output:
        estimate = "out/analysis/{iModel}.{iSubset}.rds"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --model {input.model} \
            --subset {input.subset} \
            --out {output.estimate}"

rule make_figures:
    input:
        expand("out/figures/{iFigure}.pdf",
                    iFigure = PLOTS)


rule figure:
    input:
        script = "src/figures/{iFigure}.R",
        data   = "out/data/mrw_complete.csv",
        subset = "src/data-specs/subset_intermediate.json"
    output:
        fig = "out/figures/{iFigure}.pdf"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --subset {input.subset} \
            --out {output.fig}"


rule gen_regression_vars:
    input:
        script = "src/data-management/gen_reg_vars.R",
        data   = "out/data/mrw_renamed.csv",
        param  = "src/data-specs/param_solow.json"
    output:
        data   = "out/data/mrw_complete.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --param {input.param} \
            --out {output.data}"

rule rename_vars:
    input:
        script = "src/data-management/rename_variables.R",
        data   = "src/data/mrw.dta"
    output:
        data = "out/data/mrw_renamed.csv"
    shell:
        "Rscript {input.script} \
            --data {input.data} \
            --out {output.data}"


rule clean:
    shell:
        "rm -rf out/*"

rule clean_data:
    shell:
        "rm -rf out/data/*"

rule clean_analysis:
    shell:
        "rm -rf out/analysis/*"
```

:::

In the previous chapter we have introduced wildcards to target rules with help of the `expand()` function.
This required us to construct lists with the values we want the `expand()` function to match manually.

Our `Snakefile` therefore now has three lists of values which we created for this purpose:

```{r, engine = 'out', eval = FALSE}
MODELS = [
          "model_solow",
          "model_aug_solow"
         ]

DATA_SUBSET = [
               "subset_oecd",
               "subset_intermediate",
               "subset_nonoil"
              ]

FIGURES = [
           "aug_conditional_convergence",
           "conditional_convergence",
           "unconditional_convergence"
          ]
```

This is not too problematic when we only have a few values that we want the wildcard to take, but manually specifying long lists can get tedious and is prone to error.
We also have to remember to update the lists manually when we create or rename files in our project folder.

It would be much nicer if the could create target lists automatically from the files present in our project folder.
This guarantees that the list of target files is always up to data.

Snakemake has a built-in function `glob_wildcards()` that will help us to replace the manual listing of values with an automatic one.

## The `glob_wildcards()` Function

Let's start by trying to replace the `MODELS` list with a more automated approach.
The `glob_wildcards()` function takes one input -- the path of the files that we want to search combined with the part of the file name we want to extract as a wildcard.
It then looks to find matches and collects what it finds along the way.

Let's look at `glob_wildcards()` in action to get a sense of what will happen.
We replace our manually specified `MODELS` list with the following code:

```{r, engine = 'out', eval = FALSE}
MODELS = glob_wildcards("src/model-specs/{mname}")
```

This says: "look inside the `src/model-specs/` folder, and return any files you find there".
`{mname}` is the name of the wildcard we use to tell snakemake we want the filenames from inside the folder.
The name `{mname}` itself doesn't matter, we can use whatever we like.
We choose `{mname}` because it suggests we want model names.

Next, to see the results of our matching, we remember that Snakemake will execute any Python 3 code it finds in `Snakefile`.
We can therefore use the `print()` function to print `MODELS` to the screen.

Let's add the print statement and do a dry-run:

```{r, engine = 'out', eval = FALSE}
MODELS = glob_wildcards("src/model-specs/{mname}")
print(MODELS)
```

```{r, engine = 'out', eval = FALSE}
$ snakemake --dryrun
```

We are interested in the first printed lines (in white text):

```{r, engine = 'out', eval = FALSE}
Wildcards(fname=['.gitkeep', 'model_solow.json', 'model_aug_cc_restr.json',
                'model_solow_restr.json', 'model_cc.json', 'model_ucc.json',
                'model_aug_solow_restr.json', 'model_aug_cc.json', 'model_aug_solow.json'])
```

Compared to our original `MODELS` list we see three differences

1. There are more .json files, because there are more specifications to run than we manually specified before^[You can verify this via `ls src/model-specs`]
2. There is a .gitkeep file
3. Each `mname` includes the `model_` part of the name and the file ending `.json`, which we didn't have earlier.

The first point is nice and shows us that `glob_wildcards()` is working well.
However, we want to fix points 2 and 3 to make our list compatible with the code we have developed so far.

We can do this in a single step.
We want `glob_wildcards()` to only match `.json` files whose name starts with `model_` and we do  want to include both bits in the wildcard.
To do that, we pull both `model_` and `.json` out of the `{fname}` wildcard like so:

```{r, engine = 'out', eval = FALSE}
MODELS = glob_wildcards("src/model-specs/model_{fname}.json")
print(MODELS)
```

This says: "store the part of the filename that comes between `model_` and `.json` for all files in `src/model-specs` which begin with `model_` and end in `.json` in the `MODELS` list".

Now let's try the dry run again: 

```{r, engine = 'out', eval = FALSE}
$ snakemake --dryrun
```
Now the first line is:
```{r, engine = 'out', eval = FALSE}
Wildcards(mname=['solow', 'aug_cc_restr',
                'solow_restr', 'cc', 'ucc',
                'aug_solow_restr', 'aug_cc', 'aug_solow'])
```

That's looks pretty good.
However, the dry-run command still gives an error.
It complains about missing input files.

The reason for this is a technical one:
The `glob_wildcards()` function does not directly output a list of values.
It instead returns a `Wildcards` class object which contains the list as an attribute.^[
    To see this, we can replace `print(MODELS)` with `print(type(MODELS))` and do another dry-run. 
]
We can access the list via the name we have assigned to the wildcard, in our case `mname`.^[
    Snakemake chooses this behavior because it allows us to assign and access multiple wildcards in a single run of the `glob_wildcard()` function. We could for example use `glob_wildcards("src/model-specs/model_{mname}.{fending}")` to access both the mdeol name and the file ending separately.
]


Our final step is to extract this list so that we can use it like our old `MODELS` list.

We do this as follows:

```{r, engine = 'out', eval = FALSE}
MODELS = glob_wildcards("src/model-specs/model_{mname}.json").mname
print(MODELS)
```

Read this as "get the list called `mname` from inside the Wildcards object and save it as `MODELS`".

Now if we do a dry-run: 

```{r, engine = 'out', eval = FALSE}
$ snakemake --dryrun
```

We are returned the following lines at the beginning of the output:

```{r, engine = 'out', eval = FALSE}
['solow', 'aug_cc_restr', 'solow_restr',
 'cc', 'ucc', 'aug_solow_restr',
 'aug_cc', 'aug_solow']

 ...
```

which is the list we had manually entered before plus some extra models from @mrw.

The dry-run output also shows us that there are many extra steps to run next time it is executed.
It now needs to run the steps for all the extra models we have just added.
It will create the output from each of 8 models estimated on all three of the data subsets in `DATA_SUBSET`.
So far we have estimated two models, `aug_solow` and `solow`. 
This means there are six models left to run, each across 3 data sets, for a total of 18 steps.

The job count of the dry-run output shows us that this exactly what is going to happen:

```{r, engine = 'out', eval = FALSE}
Job counts:
        count   jobs
        18      model
        1       run_models
        19
```

Let's run Snakemake to get all of the estimates.

```{r, engine = 'out', eval = FALSE}
$ snakemake --cores 1 run_models
```

We see that `glob_wildcards()` are very powerful.
It's relatively easy way to construct a list of wildcards to iterate over based on the names of files.
It also allows us to keep our file dependencies up to date without having to remember to update file lists manually.

### Looking at the DAG (redux)

With the addition of all of these new model estimates, Figure XX shows that the project's DAG has expanded in complexity. 

```{r, fig.align="center", echo=FALSE}
knitr::include_graphics("img/ch-5d/dag.pdf")
```

The DAG again makes clear what our workflow is doing.
Reading from the bottom of the figure upwards:

- Snakemake wants to build the inputs listed in  `run_models`. 
  This is the pairwise combination of all `MODELS` that were found in `src/model-specs` and all `DATA_SUBSETS` found in `src/data-specs` 
- It can build those inputs by running the `model` rule $8 \times 3 = 24$ times when it iterates over the wildcards
- To run each model, it needs the cleaned data, so it needs to run the two data managment steps first

::: {- .tip}

Notice (again) how the figures aren't produced automatically. 
Do you remember why?
If not, revisit Chapter XX.
You can build them with `snakemake --cores 1 make_figures`.
Chapter XX will show us how to get all the outputs build with one run of Snakemake.

:::

::: {- .challenge} 

### Exercise: Exploring glob_wildcards() {-}

Our `Snakefile` still has two manually specified lists, `DATA_SUBSET` and `PLOTS`.

1. Use the `glob_wildcards()` function to automate the the list construction.
2. Verify that your globbing works correctly with help of the `--dryrun` option and a `print()` statement
2. Clean the output directory
3. Run Snakemake so that all models and all figures are produced.

:::

::: {- .answer} 

### Solution {-}

Our updated lists should look like this:

```{r, engine = 'bash', eval = FALSE}
# --- Dictionaries --- #

MODELS = glob_wildcards("src/model-specs/model_{mname}.json").mname 
DATA_SUBSET = glob_wildcards("src/data-specs/subset_{sname}.json").sname
PLOTS = glob_wildcards("src/figures/{pname}.R").pname
```

We can confirm they are correct by  adding a print statement in `Snakefile` like so:


```{r, engine = 'bash', eval = FALSE}
# --- Dictionaries --- #

MODELS = glob_wildcards("src/model-specs/model_{mname}.json").mname 
DATA_SUBSET = glob_wildcards("src/data-specs/subset_{sname}.json").sname
PLOTS = glob_wildcards("src/figures/{pname}.R").pname

print(MODELS.fname)
print(DATA_SUBSET.fname)
print(PLOTS.fname)

[...]
```

We can use a dry run to print them to screen:

```{r, engine = 'bash', eval = FALSE}
# --- Dictionaries --- #
snakemake --dryrun
```

To build both the models and figures, we need to run snakemake twice:

```{r, engine = 'bash', eval = FALSE}
snakemake --cores 1 run_models
snakemake --cores 1 make_figures
```

:::