# Project Organization

## Learning Objectives {-}

TODO: Turn these into actual goals

* Separate inputs and outputs 
* Separate directories by function
* Minimize hard-coded information inside scripts 

## Subtitle TBD

As researchers and students we are famililar with the notion a paper or report needs to be written in a 
  clean and organized way that can be understood by ourselves and others.
Papers and reports have a logical structure, and are broken into logical chunks.
When the conclusions are driven by assumptions or ... we try to make this explicit by
  highlighting where they are or having a separate section to introduce them.
When logic is unclear and assumptions are not clearly laid out, 
  we are encouraged to organize written our arguments in a better way.

The idea of maintaining a clean and organized structure often does not extend to our thinking about the code and data
  that are used to construct the paper's main results.
Despite our best intentions to keep our code and data organized and coherent as researcher, 
  it too often becomes one of the first principles we throw out - 
  either when the complexity grows too large,
  or when looming deadlines favour the production of results rather than how clean the scripts that produce them look.^[
    This propensity to pre-maturely throw out code and data organization is something the authors of this tutorial
     can relate to, as it has often tempted us in our own research - and even when writing this tutorial.
     ]

Until recently, our paper's "backend" of code and data is typically only visible to the authors of a project, 
  meaning any frustration and difficulties brought about by bad code and data organization fell only on us, 
  the authors.
The rise of open science and reproducibility requirements by publishers have started to open up these backends, 
  increasing the need for our code and data to be structured in a way that that is amenable to others to look at and understand.
As a result, the pressure to adopt a coherent way to organize our research project's files has risen 
  beyond keeping the frustations of our coauthors and our future-selves in check, demanding a solution.

This aim of this chapter is to provide an example structure for a research project and 
  explain the logic behind the structure we propose.
There are two core principles behind the way we organize the files for a project:
  (1) the separation of logical chunks of a project's code and data, and 
  (2) the separation of parameters, specifications and paths from code.
A side benefit of both of these principles is that our project's structure becomes portable across multiple research projects.
This means that once we make a decision to adopt a structure, we can continue to use the same structure repeatedly into the future.^[
    Our own personal experience suggests that this side benefit reaps just as many rewards.
    Knowing immediately where to look for pieces of code and parameterizations because all our projects look identical in their organization is definitely a frustration reducing benefit of structure.
]

We are going to use the files and structure of the folder you have downloaded that replicates Mankiw, Romer and Weil's analysis (hereafter MRW) to look explore one way to organize a research project.^[
 We discussed downloading these files HERE along with any software you need to install to work through subsequant chapters.
 ]
The organization of code and data that you will see emphasizes the notions of separating logical chunks of 
  code, data, file paths & specifications, along with the files that the statistical analysis that R produces.
As you work through what follows you may begin to question the extent of logical separation, and whether it is a step too far. 
If this is where your thoughts start to go, 
  also reflect on how this structure could be extended if this project were to develop further and
  on how readily it could be adopted for use in a new project.

## Project Organization I: Separating Inputs and Outputs

Structuring our project and the locations of files is an important concept.

Let's look at the structure of our project's folder.
Open a terminal and change into this directory

```{r cd-bash, engine = 'bash', eval = FALSE}
cd YOUR/PATH/TO/snakemake-econ-r-student
```

And list the subdirectories of the main directory

```{r ls-bash, engine = 'bash', eval = FALSE}
ls -d */
```

We see the following folder structure
```{r ls-bash-res, engine = 'bash', eval = FALSE}
./
    |- src/
    |- out/
    |- log/
    |- sandbox/
```


We recommend the following structure for any project:

* Root Folder
* `src` folder for input files
* `out` folder for output files
* a `log` folder to store computer logs
* a `sandbox` folder that gives us a 'safe place' to develop new code

We discuss each of these in turn.

### The Root Folder

TBD

### The `src` folder

TBD

### The `out` folder

TBD

### The `log` folder

### Exploring the Full Structure of the MRW Replication Project

Now, let's look at all contents of this main projects directory:

```{r ls-bash-2, engine = 'bash', eval = FALSE}
ls -F .
```

We see the following folder structure
```{r ls-bash-res-2, engine = 'bash', eval = FALSE}
./
    |- src/
    |- out/
    |- log/
    |- sandbox/
    | README.md
    | Snakefile
```

Notice that there are no instances of:
    (i) scripts,
    (ii) files containing content of the paper or slides
    (iii) something else we haven't thought of yet
Instead, there are only two files, a `README.md` and a file called `Snakefile.`

TODO: explain these two files

## Project Structure II: Separating Logical Chunks of the Project

As we have mentioned above, to keep our project's structure clean, we want to keep all the computer code inside the `src` directory.
Let's have a look at the content of `src`.

```{r ls-bash-src, engine = 'bash', eval = FALSE}
ls -F src/
```

We see the following output:
```{r ls-bash-src-res, engine = 'bash', eval = FALSE}
./
    |src/
        |- data/
        |- data-management/
        |- data-specs/
        |- analysis/
        |- model-specs/
        |- lib/
        |- figures/
        |- tables/
```

The type of content we expect in each file is:

TBD


### Exploring the Structure of the MRW Replication Subdirectories

We begin our exploration of the project by looking at the folders that appear to be related to the data.
If we look inside the `data` directory

```{r ls-bash-data, engine = 'bash', eval = FALSE}
ls -F src/data/
```

```{r ls-bash-data-res, engine = 'bash', eval = FALSE}
mrw.dta
```

That is, our `data/` directory contains the project's original data set.

Note that in more extensive projects, the `data/` subfolder would typically have more than one data set.
For example:

```{r ls-bash-data-2, engine = 'bash', eval = FALSE}
dataset1.dta
dataset2.dta
dataset3.csv
```

TBD - aside on file endings.

Further, your data folder may even contain further subdirectories that organize data further

```{r ls-bash-data-3, engine = 'bash', eval = FALSE}
./
    |src/
        |- data/
            |- data-provider-a/
                |- dataset1.csv
                |- dataset2.csv
            |- data-provider-b/
                |- dataset3.txt
                |- dataset4.txt
```

If we now turn to the `data-management` directory, we can explore it's contents too:

```{r ls-bash-datamgt, engine = 'bash', eval = FALSE}
ls -F src/data-management/
```

```{r ls-bash-datamgt-res, engine = 'bash', eval = FALSE}
rename_variables.R
gen_reg_vars.R
```

TODO:

* meaningful filenames
* Note two different ways to name files


### Exercise: Exploring the Remaining Subdirectories {- .exercise}
TBD

## Project Structure III: Separating Input Parameters from Code

Next we look at the somewhat mysteriously named `data-specs` folder.

And if we explore the folder's contents:

```{r ls-bash-dataspec, engine = 'bash', eval = FALSE}
ls -F src/data-specs/
```

```{r ls-bash-dataspec-res, engine = 'bash', eval = FALSE}
subset_intermediate.json
subset_nonoil.json
subset_oecd.json
```

Again, the file names are somewhat meaningful on their own - they appear to be some way of subsetting data (selecting some rows).
If we look inside one of these files:

```{r ls-bash-dataspec2, engine = 'bash', eval = FALSE}
cat src/data-specs/subset_oecd.json
```

```{r ls-bash-dataspec2-res, engine = 'bash', eval = FALSE}
{
    "KEEP_CONDITION": "oecd == 1"
}
```

We see an a variable `KEEP_CONDITION` which is storing a string `"oecd == 1"`.

TBD: Why have we done this? See below.

### Exploring Parameter Separation in the MRW Replication Project
